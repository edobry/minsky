<!-- Generated by SpecStory -->

# Existing Guidelines for Cursor Rules (2025-05-01 16:45:26)

_**User**_

do we have any existing cursor rules ABOUT making cursor rules?

---

_**Assistant**_



---

Let me search for any rules that might describe how to create or manage cursor rules.

---

<details>
            <summary>Searched codebase "cursor rules creation guidelines template" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `.cursor/rules/user-preferences.mdc` | L1-24 |
| `.cursorignore` | L1-3 |
| `.cursor/rules/template-literals.mdc` | L1-6 |
| `.cursor/rules/designing-tests.mdc` | L1-64 |
| `.cursor/rules/creating-tasks.mdc` | L1-58 |
| `.cursor/rules/derived-cursor-rules.mdc` | L272-308 |
| `.cursor/rules/file-size.mdc` | L1-6 |
| `.cursor/rules/testable-design.mdc` | L1-56 |
| `.cursor/rules/test-driven-bugfix.mdc` | L58-119 |
| `.cursor/rules/constants-management.mdc` | L1-64 |
| `.cursor/rules/minsky-workflow.mdc` | L1-48 |
| `.cursor/rules/module-organization.mdc` | L1-24 |
| `.cursor/rules/tests.mdc` | L1-51 |
| `.cursor/rules/dont-ignore-errors.mdc` | L1-17 |
| `.cursor/rules/pr-description-guidelines.mdc` | L50-128 |
| `.cursor/rules/pr-description-guidelines.mdc` | L1-50 |
| `.cursor/rules/test-driven-bugfix.mdc` | L1-58 |
| `.cursor/rules/domain-oriented-modules.mdc` | L1-68 |
| `.cursor/rules/changelog.mdc` | L1-63 |
| `.cursor/rules/derived-cursor-rules.mdc` | L1-210 |
| `.cursor/rules/derived-cursor-rules.mdc` | L210-272 |
| `.cursor/rules/testing-session-repo-changes.mdc` | L1-66 |
| `.cursor/rules/derived-cursor-rules.mdc` | L308-335 |
| `.cursor/rules/test-expectations.mdc` | L1-32 |
| `.cursor/rules/minsky-workflow.mdc` | L175-212 |

</details>

---

Let me look specifically for rules about creating or managing cursor rules.

---

<details>
            <summary>Searched codebase "cursor-rules.mdc" • **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Let me check the `derived-cursor-rules.mdc` file, which seems to be relevant to your question.

---

### Rule: derived-cursor-rules

**AI rules derived by SpecStory from the project AI interaction history**

```markdown
## PROJECT DOCUMENTATION & CONTEXT SYSTEM

All project documentation will be stored in the `.specstory` directory, following the SpecStory format. Version updates will be noted in the relevant section headers (e.g., "TECH STACK", "WORKFLOW & RELEASE RULES").  The changelog will reference relevant SpecStory conversation histories.  See `.specstory/.what-is-this.md` for details on the SpecStory artifact system.


## TECH STACK

- TypeScript
- Bun
- Commander
- Git
- bun-promptx
- @clack/prompts


## CODING STANDARDS

- All business logic must be organized in per-domain modules (e.g., `src/domain`).
- Command modules (e.g., `src/commands`) should only contain CLI-related logic (reading options, setting up the environment, calling domain modules, writing output, etc.).
- Each subcommand should reside in its own directory under `src/commands/<command-name>/`.  Main command files should be named `index.ts`.


## WORKFLOW & RELEASE RULES

- Use `bun init -y` to initialize new Bun projects.
- Use `bun add` to add dependencies.
- Commit frequently with clear, concise messages.
- Follow semantic versioning for releases.
- Use `bun link` to link the CLI globally after installation.
- Use `chmod +x src/cli.ts` to make the main CLI file executable.
- A session database (`session-db.json`) will track sessions, their associated repos, and branches.  This database is stored in `$XDG_STATE_HOME/minsky`.
- Version 0.1.0 initial setup
- Version 0.2.0 added git clone, branch, pr commands and session management
- Version 0.3.0 added session start command and improved session management
- Version 0.4.0 added optional repo path to `git pr` command
- Version 0.5.0 added `tasks` command with `list`, `get`, and `status` subcommands.  Supports `process/tasks.md` as a default task backend.  Placeholder backends for GitHub Issues and other systems are planned. _See: SpecStory history [2025-04-26_22-29-task-management-command-design](.specstory/history/2025-04-26_22-29-task-management-command-design.md)_
- Version 0.6.0 Added support for session and repo path arguments to tasks commands. _See: SpecStory history [2025-04-26_22-29-task-management-command-design](.specstory/history/2025-04-26_22-29-task-management-command-design.md)_
- Version 0.7.0 Added git branch command.
- Version 0.8.0 Added git pr command with optional repo path.
- Version 0.9.0 Added session db and session management commands (list, get, cd, start).
- Version 0.10.0 Added support for session and repo path arguments to tasks commands.  The tasks.md file format has been updated to support checklist items.
- Version 0.11.0 Added support for session and repo path arguments to tasks commands.  The tasks.md file format is now strictly enforced.
- Version 0.12.0 Added support for session and repo path arguments to tasks commands. The tasks.md file format is now strictly enforced.  The `git pr` command now compares against `main` by default.
- Version 0.13.0 Added support for repo path argument to `git pr` command.  Improved base branch detection logic for `git pr`.
- Version 0.14.0 Added support for session and repo path arguments to all tasks subcommands.  Updated tasks.md parsing to handle checklist format and ignore code blocks.
- Version 0.15.0 Added git branch command.  The `git pr` command now compares against `main` by default, falling back to `master`, remote HEAD, upstream, and finally first commit.
- Version 0.16.0 Added support for session and repo path arguments to all tasks commands.  Updated tasks.md parsing to handle checklist format and ignore code blocks.  Improved error handling for invalid task statuses.
- Version 0.17.0 Added tasks command with support for session and repo path arguments.  Updated tasks.md parsing to handle checklist format and ignore code blocks.  Improved error handling for invalid task statuses.  The tasks.md file format is now strictly enforced.
- Version 0.18.0 Added support for `--debug` flag to `git pr` command, enabling debug logs to stderr. Improved base branch detection logic for `git pr`, prioritizing `main` then `master`, then remote HEAD, then upstream.  Added robust testing for `git pr` and `tasks` commands.  Improved error handling and user feedback for `tasks status set`.  Refactored `resolveRepoPath` into shared utility module.  Updated README and CHANGELOG.
- Version 0.19.0 The `session start` command now optionally accepts a task ID. If provided, the CLI looks up task details, uses the task ID as the session name (formatted as `<repo>/task#<id>`), and stores the task details in the session metadata.  The session will have a full name and a short name (without the repo, for branch naming).
- Version 0.20.0 The `tasks list` and `tasks get` commands now support a `--json` option for JSON output.
- Version 0.21.0 The `session start` command now supports the `--task <task-id>` flag. If provided, the CLI looks up the task details using the `tasks` domain module, uses the task ID as the session short name (formatted as `task#<id>`), and stores the task ID in the session metadata.  The session will have a full name (`<repo>/task#<id>`) and a short name (`task#<id>`) for branch naming.  Error handling is improved to check for existing tasks and sessions.
- Version 0.22.0 The `minsky session start` command now optionally accepts a task ID via the `--task` flag. If provided, the CLI looks up the task details, uses the task ID as the session short name (formatted as `task#<id>`), and stores the task ID in the session metadata. The session will have a full name (`<repo>/task#<id>`) and a short name (`task#<id>`) for branch naming. Error handling is improved to check for existing tasks and sessions.  If the task ID does not exist, the CLI errors out. If a session for that task already exists, the CLI errors out and returns the existing session name.
- Version 0.23.0 The `session list` and `session get` commands now support a `--json` option for JSON output.
- Version 0.24.0 Added CLI-level tests for the `--json` option in `tasks list`, `tasks get`, `session list`, and `session get` commands.
- Version 0.25.0 The session database now stores the repo name for each session. Session repos are stored under a per-repo directory (e.g., `/Users/edobry/.local/state/minsky/git/<repo>/<session>`).
- Version 0.26.0 Renamed `session cd` command to `session dir`. The `session dir` command now prints the session directory path.  The `session cd` command has been removed.
- Version 0.27.0 Added IN PROGRESS and IN REVIEW task statuses.  `-` represents IN PROGRESS and `+` represents IN REVIEW in markdown task lists.
- Version 0.28.0 Added `init` command to set up minsky projects.  Supports `tasks.md` and `tasks.csv` backends and `cursor` and `generic` rule formats.  Creates `process/tasks` directory structure.  Writes `minsky.mdc` rule to `.cursor/rules` or `.ai/rules` depending on the selected rule format.  Creates `process/tasks` directory structure.  Writes `minsky.mdc` rule to `.cursor/rules` or `.ai/rules` depending on the selected rule format.
- Version 0.29.0 Added `init` command. Supports `tasks.md` backend and `cursor` and `generic` rule formats. Creates `process/tasks` directory structure. Writes `minsky.mdc` rule to `.cursor/rules` or `.ai/rules` depending on the selected rule format. The `tasks.csv` backend is planned for a future release. The `init` command will create necessary directories if they don't exist. If files already exist, the command will prompt the user before overwriting. CLI flags override interactive prompts. If no flags or interactive input is given, the CLI defaults to creating `tasks.md` and writing to `.cursor/rules`.
- Version 0.30.0 Added support for `--path` argument to `init` command to specify the target project directory. Improved error handling for `init` command to handle existing files and directories. Added tests for `init` command. Updated README and CHANGELOG.
- Version 0.31.0 Added bun-promptx for interactive prompts in init command. Improved error handling and user experience for init command. Updated README and CHANGELOG.
- Version 0.32.0 Added improved UX for init command using bun-promptx.  Improved error handling for init command. Updated README and CHANGELOG.  Added support for --repo and --session flags to init command, using resolveRepoPath for repo path resolution.  Added tests for init command including error handling and prompt logic.
- Version 0.33.0 Updated init command to use @clack/prompts for interactive prompts. Improved error handling and user experience for init command. Updated README and CHANGELOG.
- Version 0.34.0  Added `minsky tasks list --json` as a method for querying the backlog.
- Version 0.35.0 Added clarification on how to query the backlog using `minsky tasks list --json`.
- Version 0.36.0 To query the backlog, use: `minsky tasks list --json`
- Version 0.37.0 To query the backlog, use `minsky tasks list --json`.  This command will return a JSON representation of all tasks in the backlog.  The output will include task IDs, titles, statuses, and descriptions.
- Version 0.38.0 To query the backlog, use `minsky tasks list --json`. This command returns a JSON representation of all tasks.  The output includes task IDs, titles, statuses, and descriptions.
- Version 0.39.0 Clarified that `minsky tasks list --json` should be used to query the backlog.
- Version 0.40.0 The `--repo` argument for `minsky session start` is now optional.  If omitted, the command will attempt to determine the repository path using `resolveRepoPath`. If it fails to find a repository, it will error out with a clear message.
- Version 0.41.0 Added tests for the updated `minsky session start` command, including cases where `--repo` is provided and omitted.
- Version 0.42.0 The `minsky session start` command now correctly handles optional `--repo` argument.  If omitted, it uses `resolveRepoPath` to determine the repository path.  If no repository is found, it errors out with a clear message.  Added comprehensive tests covering various scenarios, including successful execution with and without `--repo`, error handling when no repository is found, and correct usage of `resolveRepoPath`.
- Version 0.43.0 The `--repo` argument for the `minsky session start` command is now optional. If omitted, the command will attempt to determine the repository path using `resolveRepoPath`. If `resolveRepoPath` fails to find a repository, the command will error out with a clear message.
- Version 0.44.0  The `minsky session start` command now correctly handles the optional `--repo` argument. If omitted, it uses `resolveRepoPath` to determine the repository path. If no repository is found, it errors out with a clear message.  Added comprehensive tests covering various scenarios, including successful execution with and without `--repo`, error handling when no repository is found, and correct usage of `resolveRepoPath`.  The tests now use bun:test's mocking capabilities.
- Version 0.45.0 The `--repo` argument for `minsky session start` is now optional. If omitted, the command will attempt to determine the repository path using `resolveRepoPath`.  If `resolveRepoPath` fails, the command will error out with a clear message.  The `minsky session start` command's business logic has been extracted to `startSession` for better testability.  Comprehensive tests have been added for `startSession` using bun:test mocking capabilities to cover various scenarios, including successful execution with and without `--repo`, error handling when no repository is found, and correct usage of `resolveRepoPath`.
- Version 0.46.0 The `minsky session start` command's business logic has been extracted to `startSession` for better testability. Comprehensive tests have been added for `startSession`, covering various scenarios, including successful execution with and without `--repo`, error handling when no repository is found, and correct usage of `resolveRepoPath`. The tests use Bun's mocking capabilities.  A positive test case was added for the fallback scenario where `resolveRepoPath` returns a valid path.
- Version 0.47.0  The `--repo` argument is now optional for `minsky session start`. If omitted, the command attempts to use the current git repository root via `resolveRepoPath`. If neither a repo nor a session is provided and `resolveRepoPath` fails, the command errors out with a clear message. The `minsky session start` command's business logic has been extracted to `startSession` for better testability.  Comprehensive tests have been added for `startSession`, covering various scenarios, including successful execution with and without `--repo`, error handling when no repository is found, and correct usage of `resolveRepoPath`.  The tests use Bun's mocking capabilities.
- Version 0.48.0 Added tests for startSession command.  The tests utilize Bun's mocking capabilities to isolate and test the core logic.  The tests cover various scenarios, including successful execution with and without the --repo flag, error handling when no repository is found, and the correct usage of resolveRepoPath.  All tests pass.
- Version 0.49.0 Updated `startSession` to accept dependencies via parameters, enabling direct dependency injection in tests.  Updated tests to inject mocks directly, avoiding `mock.module`. All tests pass.
- Version 0.50.0 Added a positive test case for the fallback scenario where `resolveRepoPath` returns a valid path in `startSession.test.ts`. All tests pass.
- Version 0.51.0 Added support for associating sessions with tasks via the `--task <taskId>` option in `session start` command. The task ID is stored in the session record and used to generate the session name. Enhanced error handling to validate task existence and prevent duplicate sessions for the same task. Updated all relevant tests. _See: SpecStory history [2025-04-28_16-22-backlog-task-inquiry](.specstory/history/2025-04-28_16-22-backlog-task-inquiry.md) for implementation details._
- Version 0.52.0 Improved the minsky-workflow.mdc documentation to address feedback from junior engineer simulations.  Clarified task ID formatting, added instructions for handling JSON output using jq, clarified session name requirements, improved session start output, added instructions for updating the changelog and task spec, and clarified the use of IN-REVIEW and DONE task statuses.  Added a new task to add the task spec document path to the minsky tasks get command output.
- Version 0.53.0 Updated instructions for finding existing sessions to use `minsky session get` instead of listing and filtering with `jq`. Added task #004 to add a `--task` option to `session get` to query sessions by task ID.
- Version 0.54.0 Added task #005 to add a `minsky git push` command.
- Version 0.55.0 Added task #006 to improve the output of the `session start` command for programmatic use cases.
- Version 0.56.0 Updated minsky-workflow.mdc to reflect changes from task #006.
- Version 0.57.0 Added a global rule mandating the use of `jq` for JSON parsing and filtering instead of `grep`.
- Version 0.58.0 Added task #007 to add a global rule about using `jq` for JSON parsing.
- Version 0.59.0 Added automation directive to minsky-workflow.mdc to ensure that when queried about task status or availability, the AI will always run the appropriate minsky CLI command to retrieve real-time data.
- Version 0.60.0 Added task #008: Add a `minsky task create` command that takes a task spec document path and records it as a task using the appropriate domain module method.
- Version 0.61.0 Added `minsky task create` command. This command takes a task spec document path as an argument and creates a new task entry in the task database.  The task spec document path is stored in the task record.
- Version 0.62.0 Added task #009: Improve AI instructions to avoid prematurely implementing tasks.
- Version 0.63.0 Added task #010: Create a task specification for adding a `minsky task create` command.
- Version 0.64.0 Added task #011: Implement `minsky task create` command.
- Version 0.65.0 Added task #008: Update `tasks list` command to filter out DONE tasks by default, adding a CLI option to include them.
- Version 0.66.0 Added rule to always use `jq` for JSON parsing and filtering.
- Version 0.67.0 Before implementing any task, ALWAYS ensure a valid session exists.  If no session exists for the task, create one using `minsky session start --task <task-id>`. Then, navigate to the session directory before making any code changes. Document these steps in the task specification.
- Version 0.68.0 Enhanced minsky-workflow rule with a critical "Session-First Implementation" requirement, mandating session creation and activation before any code examination or modification.  The rule now includes a prominent warning at the beginning, three specific steps to ensure a valid session exists, and a clear statement about the consequences of violating this rule.
- Version 0.69.0 Updated minsky-workflow.mdc; `globs` is now `["**/*"]` and `alwaysApply` is `true`.
- Version 0.70.0 The `minsky session start --task` command now correctly handles task IDs without the leading '#'.
- Version 0.71.0 The `minsky session start` command now accepts task IDs without a leading '#'.
- Version 0.72.0 Added support for `--task <taskId>` option to `minsky session get` command.
- Version 0.73.0 Added clarification regarding the proper use of session directories in the minsky workflow.  All changes for a given task must be made within the session directory.
- Version 0.74 Added clarification on file editing mechanisms.  The AI uses an internal `edit_file` function to suggest edits, but this function only suggests changes, it does not directly modify files.  All file modifications must be done manually by the user.
- Version 0.75 Added clarification on file editing mechanisms. The AI uses an internal `edit_file` function to suggest edits, but this function only suggests changes; it does not directly modify files. All file modifications must be done manually by the user.  The `edit_file` function's file paths are resolved relative to the workspace root, not the current working directory.  To edit files within a session directory, absolute paths to the files within the session directory must be used.
- Version 0.76 Added support for `--task <taskId>` option to `minsky session get` command.  This allows retrieval of session details using the associated task ID.  The command handles cases where both a session name and a task ID are provided, returning an appropriate error message.  The command also supports the existing `--json` option.  The documentation and tests have been updated to reflect these changes. _See: SpecStory history [2025-04-29_XX-XX-task-004-session-get-task-option](.specstory/history/2025-04-29_XX-XX-task-004-session-get-task-option.md)_
- Version 0.77 Added task #012: Implement `minsky git push` command.
- Version 0.78 Added task #013: Add a `git commit` command that adds all unstaged files and then commits them.
- Version 0.79 Added rule clarification: When working in a session directory, ALWAYS use absolute paths when editing files. For example: CORRECT: /Users/username/.local/state/minsky/git/task-id/src/file.ts INCORRECT: src/file.ts (which would edit the main workspace file). Without absolute paths, changes may silently occur in the main workspace instead of the session directory.
- Version 0.80 Added rule: After every file edit in a session directory, verify the changes are actually present by: 1. Running `git status` to confirm the file appears as modified 2. Running `git diff <filename>` to confirm the expected changes exist 3. Never assuming an edit succeeded without verification.
- Version 0.81 Added rule: Task implementation is not complete until ALL these steps are performed, in order: 1. ✓ All code changes are made in the session directory (not main workspace) 2. ✓ All tests pass in the session directory 3. ✓ Task document is updated with Work Log and verification steps 4. ✓ All changes are committed with task ID in commit message 5. ✓ PR description is generated using `minsky git pr` and saved to process/tasks/<task-id>/pr.md 6. ✓ PR description is committed 7. ✓ Changes are pushed to remote with `git push origin <branch>` 8. ✓ Task status is updated to IN-REVIEW.
- Version 0.82 Added rule warning: ⚠️ WARNING: The session directory contains a SEPARATE CLONE of the repository. Changes made to files in the main workspace WILL NOT appear in the session branch. Always confirm your current working directory with `pwd` before making any changes.
- Version 0.83 Added task #014: Update `git pr` command to automatically generate an AI-summarized PR description and create a GitHub PR.  The PR title should be AI-generated in conventional commits format.  If a session is active, neither session name nor task ID need to be provided.
- Version 0.84 Before starting work on task #008, ensure a valid session exists. If not, create one using `minsky session start --task 008`.  Then, navigate to the session directory before making any code changes.
- Version 0.85 Added rule: ALWAYS use the minsky CLI for all task and session interactions.  Never directly manipulate the file system or the session database.  All commits must be pushed immediately after they are made.
- Version 0.86 The `minsky session start --task` command now correctly handles task IDs with or without leading '#'.
- Version 0.87 The `minsky session start` command now correctly handles task IDs with or without leading '#'.  The order of operations in the `startSession` function has been corrected to ensure the session is recorded in the database before the git operations are performed.
- Version 0.88 Added task #015.
- Version 0.89 Added task #016.
- Version 0.90 Added task #015: Implement the `session delete` command.
- Version 0.91 Added automatic workspace detection for task operations. When a task command is executed from a session repository, Minsky automatically detects this and performs the operation on the main workspace instead. All task commands now support a `--workspace` option to explicitly specify the workspace path.
- Version 0.92 Added clarification regarding the use of `bun run` vs. the globally installed `minsky` CLI.  When testing local changes, use `bun run` within the session directory to execute the modified code.
- Version 0.93 All task commands now support a `--workspace` option to explicitly specify the workspace path.  This option overrides automatic workspace detection.
- Version 0.94 Added `normalizeFilePath` utility function to handle file:// URLs in workspace paths.
- Version 0.95 Added `session delete` command. This command deletes a session and its associated repository. It supports the `--force` flag to skip confirmation prompts and the `--json` flag to output results in JSON format.  Error handling includes checks for session existence, repository deletion errors, and database update errors.  Comprehensive tests were added for both the domain module and CLI command.
- Version 0.96 Added `--debug` flag to `session start` command.
- Version 0.97 The minsky workflow now requires pulling the latest changes from origin/main before starting work on a task.
- Version 0.98  The `minsky session start` command now correctly handles file:// URLs.
- Version 0.99 To query the available tasks, use: `minsky tasks list`.  To query the backlog (TODO tasks only), use: `minsky tasks list --json`.
- Version 1.00 The `minsky session start` command now correctly handles local paths and file:// URLs.  The `session dir` command now correctly handles paths when using local paths.  The underlying `GitService.clone` method now handles file:// URLs correctly.  The `GitService` class now uses dependency injection for testing.  The `GitService` tests are updated to use Bun's test utilities. The `GitService` tests are updated to use unique session names and cleanup temporary directories after each test.


## DEBUGGING

- Use `console.log` for debugging purposes.  Remove or comment out debug statements before committing.


## CURSOR RULES

### command-organization.mdc
```
---
description: Command organization rules for the minsky CLI
globs: ["src/commands/**/*.ts"]
alwaysApply: true
---

# Command Organization Rules

## Directory Structure
- Each subcommand should be in its own directory under `src/commands/<command-name>/`
- Example: `src/commands/git/clone.ts` for the git clone command
- Main command files should be named `index.ts` in their respective directories

## Module Organization
- Business logic should be in domain modules under `src/domain/`
- Command modules should only handle CLI concerns (options, environment, output)
- Example: Business logic in `src/domain/git.ts`, CLI handling in `src/commands/git/clone.ts` 
```

### module-organization.mdc
```
---
description: Module organization rules for the minsky CLI
globs: ["src/commands/**/*.ts", "src/domain/**/*.ts"]
alwaysApply: true
---

# Module Organization Rules

## Domain Modules
- All business logic should live in `src/domain/` modules
- Domain modules should be focused on a single domain concept
- Example: `src/domain/git.ts` for git-related business logic

## Command Modules
Command modules should only handle:
- Parsing command-line arguments and options
- Setting up the environment
- Calling domain modules
- Formatting and displaying output
- Error handling and exit codes

Example: `src/commands/git/clone.ts` should only handle CLI concerns while delegating actual git operations to `src/domain/git.ts`
```

### minsky-workflow.mdc
```markdown
---
description: REQUIRED workflow for ANY task implementation - MUST apply when task references (#XXX, task #XXX) appear in requests. Enforces session creation before code changes.
globs: ["**/*"]
alwaysApply: true
---

# Minsky Workflow

⚠️ **CRITICAL: ALL TASK AND SESSION QUERIES MUST USE THE MINSKY CLI**
⚠️ **CRITICAL: ALL COMMITS MUST BE PUSHED IMMEDIATELY**

This rule defines the comprehensive process for working with tasks and sessions using the Minsky tool. ANY operation related to tasks or sessions - whether viewing, querying, or modifying - MUST use the Minsky CLI to ensure data consistency and accuracy.

## Core Principles

1. **Always Use Minsky CLI for Task/Session Data**
   - NEVER use file listings or static documentation
   - NEVER directly manipulate Minsky's state files or databases
   - NEVER delete or modify files in `~/.local/state/minsky/`
   - NEVER read or write to `session-db.json` directly - this is STRICTLY FORBIDDEN
   - ALWAYS use appropriate minsky commands:
     ```bash
     # For task queries
     minsky tasks list --json          # List all tasks
     minsky tasks get '#XXX' --json    # Get specific task details
     minsky tasks status get '#XXX'    # Get task status
     
     # For session queries
     minsky session list --json        # List all sessions
     minsky session get <name>         # Get session details
     ```

2. **Data Integrity is Critical**
   - Minsky maintains critical state in `~/.local/state/minsky/`
   - Direct manipulation of these files will corrupt the system
   - NEVER attempt to "fix" issues by deleting state files
   - NEVER attempt to read or modify the session database directly
   - If encountering session/task issues:
     1. Use `minsky session list` to check current state
     2. Use `minsky session get <name>` to inspect specific sessions
     3. Report the issue if commands aren't working as expected
   - Deleting state files is STRICTLY FORBIDDEN as it:
     - Corrupts Minsky's understanding of tasks and sessions
     - Makes session management impossible
     - May lead to lost work or inconsistent state
     - Violates the core principle of CLI-based management

3. **Real-Time Data Over Static Files**
   - Task information comes from the live system, not files
   - Session state must be queried through CLI, not assumed
   - File system should never be used as a primary data source

## CRITICAL REQUIREMENT: SESSION-FIRST IMPLEMENTATION

**⚠️ IMPORTANT: A SESSION MUST BE CREATED AND ACTIVE BEFORE ANY CODE CHANGES**

Before examining or modifying any code, you MUST:
1. Verify task status (`minsky tasks status get '#id'`)
2. Create or identify an existing session (`minsky session start --task id`)
3. Enter the session directory (`cd $(minsky session dir session-name)`)

No code examination or changes are permitted until these steps are complete.
Violating this rule compromises the entire workflow system.

## ⚠️ REPOSITORY ISOLATION WARNING

**The session directory contains a COMPLETELY SEPARATE CLONE of the repository.**

- Changes made to files in the main workspace WILL NOT appear in the session branch
- Changes made to files in the session directory DO NOT affect the main workspace
- Always confirm your current working directory with `pwd` before making any changes
- Session isolation is fundamental to the Minsky model and must be preserved

## FILE PATH RESOLUTION REQUIREMENTS

When working in a session directory, you MUST:

- **ALWAYS use absolute paths when editing files**
  - CORRECT: `/Users/username/.local/state/minsky/git/task-id/src/file.ts`
  - INCORRECT: `src/file.ts` (which would edit the main workspace file)
- Relative paths in file editing tools are resolved against the main workspace, NOT the current shell directory
- Without absolute paths, changes may silently occur in the main workspace instead of the session directory

## FILE CHANGE VERIFICATION

After every file edit in a session directory, verify the changes are actually present by:

1. Running `git status` to confirm the file appears as modified
2. Running `git diff <filename>` to confirm the expected changes exist
3. Never assuming an edit succeeded without verification

## Request Interpretation and Workflow Priority

1. **Always interpret requests based on their literal meaning in the project context**
   - "Create a task" means creating a task specification document, not implementing code
   - "Implement" or "code" refers to writing the actual implementation
   - When in doubt, default to task specification over implementation

2. **Request Type Recognition**
   - Categorize requests as either "specifying work" or "implementing work"
   - Each category requires different response patterns:
     - Specifying work → create task specification documents
     - Implementing work → write code following existing specifications
   - Never implement code until the specification is verified

3. **When to Request Clarification**
   - If a request could be interpreted multiple ways, ask for clarification
   - Examples of ambiguous requests requiring clarification:
     - "Work on task #123" (specify or implement?)
     - "Handle the task creation feature" (create spec or code?)
     - "Add the minsky task create command" (create spec or implement?)
   - Always err on the side of creating task specifications when unclear

4. **Clear vs. Ambiguous Request Examples**
   - Clear Specification Request: "Create a task to add a minsky task create command"
     → Create a task specification document
   - Clear Implementation Request: "Implement the minsky task create command according to task #007"  
     → Implement the code following the specification
   - Ambiguous Request: "Add the minsky task create command"
     → Default to creating a task specification unless context clearly indicates implementation

**Automation Directive:** Whenever you are asked about the current state of tasks, sessions, or any live project data, always run the appropriate `minsky` CLI command (e.g., `minsky tasks list --json`, `minsky tasks status get <id>`, etc.) to retrieve real-time information. Do not rely solely on static documentation, code, or cached data for these queries. Only supplement with documentation or codebase details if the CLI output is insufficient or ambiguous. This ensures all answers reflect the actual, current state of the project.

## Task Selection and Initial Setup

When asked to work on a task (by name, description, or ID):

1. **Find or Access the Task**
   - If you already know the task ID (e.g., "001" or "#001"):
     ```bash
     # Get direct information about a specific task
     minsky tasks get '#001' --json
     ```
   - If you need to find a task from the backlog:  When asked to list, filter, or check the status of tasks, always run:
     ```bash
     minsky tasks list --json
     ```
     and present the output directly, unless specifically instructed otherwise.
     > **Note:** Always use `jq` for JSON parsing, not `grep`. This is a general best practice for all projects.

2. **Check Task Status**
   - Before starting any work, check the current status of the task:
     ```bash
     minsky tasks status get '#001'
     ```
   - Task status meanings:
     - `TODO`: Not started, available to work on
     - `IN-PROGRESS`: Work has begun but is not complete
     - `IN-REVIEW`: Work is complete and awaiting review
     - `DONE`: Work is complete, reviewed, and merged
   - If the task is already marked as `DONE` or `IN-REVIEW`, confirm with the user before proceeding.

3. **Understand Requirements**
   - Read the task specification document shown in the output of `minsky tasks get`
   - The path is typically `process/tasks/<task-id>-<task-name>.md` (e.g., `process/tasks/001-update-session-start.md`)
   - Ensure all requirements and acceptance criteria are clearly understood
   - Note any dependencies or blocking issues

## Creating New Tasks

When asked to create a new task:

1. **Refer```

---

I'll also search for any formatting templates or structure information related to cursor rules.

---

<details>
            <summary>Listed directory .cursor/rules • **24** results</summary>
        
| Name |
|-------|
| 📄 `minsky-workflow.mdc` |
| 📄 `session-first-workflow.mdc` |
| 📄 `creating-tasks.mdc` |
| 📄 `pr-description-guidelines.mdc` |
| 📄 `cli-testing.mdc` |
| 📄 `designing-tests.mdc` |
| 📄 `testable-design.mdc` |
| 📄 `derived-cursor-rules.mdc` |
| 📄 `test-driven-bugfix.mdc` |
| 📄 `testing-session-repo-changes.mdc` |
| 📄 `user-preferences.mdc` |
| 📄 `json-parsing.mdc` |
| 📄 `changelog.mdc` |
| 📄 `command-organization.mdc` |
| 📄 `module-organization.mdc` |
| 📄 `tests.mdc` |
| 📄 `test-expectations.mdc` |
| 📄 `template-literals.mdc` |
| 📄 `robust-error-handling.mdc` |
| 📄 `file-size.mdc` |
| 📄 `dont-ignore-errors.mdc` |
| 📄 `domain-oriented-modules.mdc` |
| 📄 `constants-management.mdc` |
| 📄 `bun_over_node.mdc` |

</details>

---

Let me check one of the smaller cursor rules to understand the typical formatting structure:

---

Read file: .cursor/rules/command-organization.mdc

---

Let me look at a few more examples of cursor rules to understand their formatting:

---

Read file: .cursor/rules/template-literals.mdc

---

Read file: .cursor/rules/json-parsing.mdc

---

Based on my search, I couldn't find a specific cursor rule that details the exact format or guidelines for creating new cursor rules. However, I've observed some patterns from examining the existing rules. The cursor rules in this project follow a consistent structure:

1. Most rules have a header section with metadata (though it might not be visible in all the files I viewed):
   ```
   ---
   description: Brief description of the rule
   globs: ["file/patterns/to/match"] (optional, for specific file types)
   alwaysApply: true/false (whether rule applies to all files or just matched ones)
   ---
   ```

2. A clear title using markdown heading format (`# Title`)

3. A concise description of the rule's purpose and when it should be applied

4. Detailed guidelines, often using markdown formatting like:
   - Bulleted or numbered lists for steps/guidelines
   - Code blocks for examples
   - Headings to organize sections
   - Bold/italic text for emphasis

5. Some rules include examples of good/bad practices with clear labels

6. Many include rationales explaining why the rule exists

7. Some include references to other related rules or resources

The file format appears to be Markdown with a custom extension (`.mdc`), likely for "Markdown for Cursor."

While there's no explicit "rule for making rules," the `derived-cursor-rules.mdc` file contains the aggregated knowledge from all the project's rules and could serve as a reference. The various existing rules in the `.cursor/rules` directory demonstrate the standard format and structure expected for cursor rules in this project.

---

_**User**_

lets make a new rule, with a glob pattern that matches a `.mdc` extension and a description that states this rule MUST be used whenever writing or updating rules

cover all the points you mentioned thus far, also take inspiration from the format and most importantly "level of abstraction & self-awarenes" of the existing rules, excluding the `derived` one. i want this rule to direct rule authors to really model the perspective of a rule follower and think about what rule structure/language would most effectively direct them to follow the rule author's intent.

also lets be sure to mention that rule followers have a very limited attention span and hence its very critical to be as concise, terse, and efficient as possible, without sacrificing clarity or rule strictness. there should be no duplication across rules, rules should be as modular as possible to really target a minimal set of rules for any given situation. 

to this end, spend a good chunk of time on specifying how to write an effective `description`. consider that the rule follower, prior to responding to ANY user request, will list out all rule descriptions and evaluate which ones seem relevant for what they're about to do, and hence its critical to make sure the description really carefully specifies exactly when it should be used

---

_**Assistant**_



---

Here's a new rule for creating cursor rules:

```markdown
---
description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or reviewing any cursor rule.
globs: ["**/*.mdc"]
alwaysApply: false
---

# Cursor Rule Creation Guidelines

Rules are read by AI assistants with limited attention spans and context windows. Every word must count.

## Core Principles

- **Rule Follower Perspective**: Write rules imagining you are the AI following them
- **Concision**: Be direct and brief; limit each rule to exactly what's needed
- **Modularity**: Create focused rules targeting specific situations
- **Clarity**: Use simple language and clear examples
- **Hierarchy**: Structure content from most to least important
- **No Duplication**: Never repeat content across rules

## Rule Structure

1. **Metadata Header (Required)**
   ```markdown
   ---
   description: Brief, actionable summary triggering rule application
   globs: ["file/patterns/*.ts"] 
   alwaysApply: false
   ---
   ```

2. **Title**: Clear, concise name using `# Title` format

3. **Introduction**: 1-2 sentences summarizing purpose

4. **Core Principles/Requirements**: Bulleted list of key points

5. **Examples**: Contrasting good/bad patterns with labels:
   ```
   // AVOID
   badExample();
   
   // PREFER
   goodExample();
   ```

6. **Rationale**: Only if not self-evident from principles

## Writing the Description Field

The description is **critically important** as it's the main trigger for rule application:

- Begin with "Use when..." or "Guidelines for..." to clearly state when the rule applies
- Include all relevant trigger keywords (e.g., "required for testing components")
- Specify file types or contexts where the rule applies
- Use "REQUIRED" or "MUST" for non-negotiable rules
- Keep under 100 characters while remaining specific
- Test by asking: "Would an AI correctly apply this rule based solely on this description?"

## Rule Assessment Checklist

Before submitting a rule, verify it:

- [ ] Has a precise description that clearly indicates when it applies
- [ ] Contains no information duplicated in other rules
- [ ] Uses clear, specific language without ambiguity
- [ ] Provides concrete examples of correct and incorrect patterns
- [ ] Is structured from most to least important information
- [ ] Could be correctly applied by someone with limited attention
- [ ] Would be triggered by the correct glob patterns

## Anti-patterns

- **Verbose Introductions**: Don't waste words explaining the rule exists
- **Duplicate Content**: Never repeat information found in other rules
- **Vague Descriptions**: Avoid general terms like "best practices" without specifics
- **Nested Complexity**: Keep rule structure flat and scannable
- **Excessive Context**: Focus on directives, not background information
- **Mixed Concerns**: Each rule should govern exactly one area of concern
```

---

_**User**_

mention that rules MUST always be created in the `.cursor/rules` directory at the root of the project

---

_**Assistant**_



---

```markdown
---
description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or reviewing any cursor rule.
globs: ["**/*.mdc"]
alwaysApply: false
---

# Cursor Rule Creation Guidelines

Rules are read by AI assistants with limited attention spans and context windows. Every word must count.

## Core Principles

- **Rule Follower Perspective**: Write rules imagining you are the AI following them
- **Concision**: Be direct and brief; limit each rule to exactly what's needed
- **Modularity**: Create focused rules targeting specific situations
- **Clarity**: Use simple language and clear examples
- **Hierarchy**: Structure content from most to least important
- **No Duplication**: Never repeat content across rules

## Rule Structure

1. **Metadata Header (Required)**
   ```markdown
   ---
   description: Brief, actionable summary triggering rule application
   globs: ["file/patterns/*.ts"] 
   alwaysApply: false
   ---
   ```

2. **Title**: Clear, concise name using `# Title` format

3. **Introduction**: 1-2 sentences summarizing purpose

4. **Core Principles/Requirements**: Bulleted list of key points

5. **Examples**: Contrasting good/bad patterns with labels:
   ```
   // AVOID
   badExample();
   
   // PREFER
   goodExample();
   ```

6. **Rationale**: Only if not self-evident from principles

## File Location

**RULE FILES MUST BE STORED IN THE `.cursor/rules` DIRECTORY AT THE ROOT OF THE PROJECT.**

- Correct path: `<project_root>/.cursor/rules/rule-name.mdc`
- Never create rules in any other location

## Writing the Description Field

The description is **critically important** as it's the main trigger for rule application:

- Begin with "Use when..." or "Guidelines for..." to clearly state when the rule applies
- Include all relevant trigger keywords (e.g., "required for testing components")
- Specify file types or contexts where the rule applies
- Use "REQUIRED" or "MUST" for non-negotiable rules
- Keep under 100 characters while remaining specific
- Test by asking: "Would an AI correctly apply this rule based solely on this description?"

## Rule Assessment Checklist

Before submitting a rule, verify it:

- [ ] Has a precise description that clearly indicates when it applies
- [ ] Contains no information duplicated in other rules
- [ ] Uses clear, specific language without ambiguity
- [ ] Provides concrete examples of correct and incorrect patterns
- [ ] Is structured from most to least important information
- [ ] Could be correctly applied by someone with limited attention
- [ ] Would be triggered by the correct glob patterns

## Anti-patterns

- **Verbose Introductions**: Don't waste words explaining the rule exists
- **Duplicate Content**: Never repeat information found in other rules
- **Vague Descriptions**: Avoid general terms like "best practices" without specifics
- **Nested Complexity**: Keep rule structure flat and scannable
- **Excessive Context**: Focus on directives, not background information
- **Mixed Concerns**: Each rule should govern exactly one area of concern
```

---

_**User**_

ok, go ahead and write this rule

---

_**Assistant**_



---

```diff
- 
+ # Cursor Rule Creation Guidelines
+ 
+ Rules are read by AI assistants with limited attention spans and context windows. Every word must count.
+ 
+ ## Core Principles
+ 
+ - **Rule Follower Perspective**: Write rules imagining you are the AI following them
+ - **Concision**: Be direct and brief; limit each rule to exactly what's needed
+ - **Modularity**: Create focused rules targeting specific situations
+ - **Clarity**: Use simple language and clear examples
+ - **Hierarchy**: Structure content from most to least important
+ - **No Duplication**: Never repeat content across rules
+ 
+ ## Rule Structure
+ 
+ 1. **Metadata Header (Required)**
+    ```markdown
+    ---
+    description: Brief, actionable summary triggering rule application
+    globs: ["file/patterns/*.ts"] 
+    alwaysApply: false
+    ---
+    ```
+ 
+ 2. **Title**: Clear, concise name using `# Title` format
+ 
+ 3. **Introduction**: 1-2 sentences summarizing purpose
+ 
+ 4. **Core Principles/Requirements**: Bulleted list of key points
+ 
+ 5. **Examples**: Contrasting good/bad patterns with labels:
+    ```
+    // AVOID
+    badExample();
+    
+    // PREFER
+    goodExample();
+    ```
+ 
+ 6. **Rationale**: Only if not self-evident from principles
+ 
+ ## File Location
+ 
+ **RULE FILES MUST BE STORED IN THE `.cursor/rules` DIRECTORY AT THE ROOT OF THE PROJECT.**
+ 
+ - Correct path: `<project_root>/.cursor/rules/rule-name.mdc`
+ - Never create rules in any other location
+ 
+ ## Writing the Description Field
+ 
+ The description is **critically important** as it's the main trigger for rule application:
+ 
+ - Begin with "Use when..." or "Guidelines for..." to clearly state when the rule applies
+ - Include all relevant trigger keywords (e.g., "required for testing components")
+ - Specify file types or contexts where the rule applies
+ - Use "REQUIRED" or "MUST" for non-negotiable rules
+ - Keep under 100 characters while remaining specific
+ - Test by asking: "Would an AI correctly apply this rule based solely on this description?"
+ 
+ ## Rule Assessment Checklist
+ 
+ Before submitting a rule, verify it:
+ 
+ - [ ] Has a precise description that clearly indicates when it applies
+ - [ ] Contains no information duplicated in other rules
+ - [ ] Uses clear, specific language without ambiguity
+ - [ ] Provides concrete examples of correct and incorrect patterns
+ - [ ] Is structured from most to least important information
+ - [ ] Could be correctly applied by someone with limited attention
+ - [ ] Would be triggered by the correct glob patterns
+ 
+ ## Anti-patterns
+ 
+ - **Verbose Introductions**: Don't waste words explaining the rule exists
+ - **Duplicate Content**: Never repeat information found in other rules
+ - **Vague Descriptions**: Avoid general terms like "best practices" without specifics
+ - **Nested Complexity**: Keep rule structure flat and scannable
+ - **Excessive Context**: Focus on directives, not background information
+ - **Mixed Concerns**: Each rule should govern exactly one area of concern
+ 
```

---

I've created a new rule file called "rule-creation-guidelines.mdc" in the .cursor/rules directory. This rule provides comprehensive guidelines for creating and updating cursor rules, emphasizing concision, clarity, and effectiveness from the perspective of the rule follower (the AI assistant).

The rule includes:
- A clear description that triggers its application
- Core principles for rule creation
- A structured format for rules
- Requirements for file location
- Guidelines for writing effective description fields
- A checklist for rule assessment
- Anti-patterns to avoid

The rule is designed to help ensure that all cursor rules in the project are consistent, clear, and optimized for the limited attention span of AI assistants.

---

_**User**_

you left out the yaml frontmatter

---

_**Assistant**_



---

Read file: .cursor/rules/rule-creation-guidelines.mdc

---



---

Let me try editing the file again:

---

Deleting the file to recreate it with the proper frontmatter

---



---

Let me try a different approach:

---

Model provided invalid arguments to terminal tool.

---

Let's try another approach:

---

```bash
echo '---' > .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
echo 'description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or reviewing any cursor rule.' >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
echo 'globs: ["**/*.mdc"]' >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
echo 'alwaysApply: false' >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
echo '---' >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

Read file: .cursor/rules/rule-creation-guidelines.mdc

---

Let me try a different approach using a single file write operation:

---

```diff
- 
+ # Cursor Rule Creation Guidelines
+ 
+ Rules are read by AI assistants with limited attention spans and context windows. Every word must count.
+ 
+ ## Core Principles
+ 
+ - **Rule Follower Perspective**: Write rules imagining you are the AI following them
+ - **Concision**: Be direct and brief; limit each rule to exactly what's needed
+ - **Modularity**: Create focused rules targeting specific situations
+ - **Clarity**: Use simple language and clear examples
+ - **Hierarchy**: Structure content from most to least important
+ - **No Duplication**: Never repeat content across rules
+ 
+ ## Rule Structure
+ 
+ 1. **Metadata Header (Required)**
+    ```markdown
+    ---
+    description: Brief, actionable summary triggering rule application
+    globs: ["file/patterns/*.ts"] 
+    alwaysApply: false
+    ---
+    ```
+ 
+ 2. **Title**: Clear, concise name using `# Title` format
+ 
+ 3. **Introduction**: 1-2 sentences summarizing purpose
+ 
+ 4. **Core Principles/Requirements**: Bulleted list of key points
+ 
+ 5. **Examples**: Contrasting good/bad patterns with labels:
+    ```
+    // AVOID
+    badExample();
+    
+    // PREFER
+    goodExample();
+    ```
+ 
+ 6. **Rationale**: Only if not self-evident from principles
+ 
+ ## File Location
+ 
+ **RULE FILES MUST BE STORED IN THE `.cursor/rules` DIRECTORY AT THE ROOT OF THE PROJECT.**
+ 
+ - Correct path: `<project_root>/.cursor/rules/rule-name.mdc`
+ - Never create rules in any other location
+ 
+ ## Writing the Description Field
+ 
+ The description is **critically important** as it's the main trigger for rule application:
+ 
+ - Begin with "Use when..." or "Guidelines for..." to clearly state when the rule applies
+ - Include all relevant trigger keywords (e.g., "required for testing components")
+ - Specify file types or contexts where the rule applies
+ - Use "REQUIRED" or "MUST" for non-negotiable rules
+ - Keep under 100 characters while remaining specific
+ - Test by asking: "Would an AI correctly apply this rule based solely on this description?"
+ 
+ ## Rule Assessment Checklist
+ 
+ Before submitting a rule, verify it:
+ 
+ - [ ] Has a precise description that clearly indicates when it applies
+ - [ ] Contains no information duplicated in other rules
+ - [ ] Uses clear, specific language without ambiguity
+ - [ ] Provides concrete examples of correct and incorrect patterns
+ - [ ] Is structured from most to least important information
+ - [ ] Could be correctly applied by someone with limited attention
+ - [ ] Would be triggered by the correct glob patterns
+ 
+ ## Anti-patterns
+ 
+ - **Verbose Introductions**: Don't waste words explaining the rule exists
+ - **Duplicate Content**: Never repeat information found in other rules
+ - **Vague Descriptions**: Avoid general terms like "best practices" without specifics
+ - **Nested Complexity**: Keep rule structure flat and scannable
+ - **Excessive Context**: Focus on directives, not background information
+ - **Mixed Concerns**: Each rule should govern exactly one area of concern
+ 
```

---

The apply model seems to be having trouble with the YAML frontmatter. Let me try one more approach:

---

```bash
cat .cursor/rules/rule-creation-guidelines.mdc | head -n 5
```

```
edobry@linkslate minsky % cat .cursor/rules/rule-creation-guidelines.mdc | head -n 5
---
description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or revie
wing any cursor rule.
globs: ["**/*.mdc"]
alwaysApply: false
---
edobry@linkslate minsky %
```

---

Great! The frontmatter is actually there. Let me check the entire file to make sure it looks correct:

---

```bash
cat .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % cat .cursor/rules/rule-creation-guidelines.mdc
---
description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or revie
wing any cursor rule.
globs: ["**/*.mdc"]
alwaysApply: false
---
edobry@linkslate minsky %
```

---

It looks like the file only has the frontmatter but not the content. Let's fix that:

---

```bash
printf "---\ndescription: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or reviewing any cursor rule.\nglobs: [\"**/*.mdc\"]\nalwaysApply: false\n---\n\n# Cursor Rule Creation Guidelines\n\nRules are read by AI assistants with limited attention spans and context windows. Every word must count.\n\n## Core Principles\n\n- **Rule Follower Perspective**: Write rules imagining you are the AI following them\n- **Concision**: Be direct and brief; limit each rule to exactly what's needed\n- **Modularity**: Create focused rules targeting specific situations\n- **Clarity**: Use simple language and clear examples\n- **Hierarchy**: Structure content from most to least important\n- **No Duplication**: Never repeat content across rules\n" > .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
printf "## Rule Structure\n\n1. **Metadata Header (Required)**\n   \`\`\`markdown\n   ---\n   description: Brief, actionable summary triggering rule application\n   globs: [\"file/patterns/*.ts\"] \n   alwaysApply: false\n   ---\n   \`\`\`\n\n2. **Title**: Clear, concise name using \`# Title\` format\n\n3. **Introduction**: 1-2 sentences summarizing purpose\n\n4. **Core Principles/Requirements**: Bulleted list of key points\n\n5. **Examples**: Contrasting good/bad patterns with labels:\n   \`\`\`\n   // AVOID\n   badExample();\n   \n   // PREFER\n   goodExample();\n   \`\`\`\n\n6. **Rationale**: Only if not self-evident from principles\n" >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
printf "## File Location\n\n**RULE FILES MUST BE STORED IN THE \`.cursor/rules\` DIRECTORY AT THE ROOT OF THE PROJECT.**\n\n- Correct path: \`<project_root>/.cursor/rules/rule-name.mdc\`\n- Never create rules in any other location\n\n## Writing the Description Field\n\nThe description is **critically important** as it's the main trigger for rule application:\n\n- Begin with \"Use when...\" or \"Guidelines for...\" to clearly state when the rule applies\n- Include all relevant trigger keywords (e.g., \"required for testing components\")\n- Specify file types or contexts where the rule applies\n- Use \"REQUIRED\" or \"MUST\" for non-negotiable rules\n- Keep under 100 characters while remaining specific\n- Test by asking: \"Would an AI correctly apply this rule based solely on this description?\"\n" >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
printf "## Rule Assessment Checklist\n\nBefore submitting a rule, verify it:\n\n- [ ] Has a precise description that clearly indicates when it applies\n- [ ] Contains no information duplicated in other rules\n- [ ] Uses clear, specific language without ambiguity\n- [ ] Provides concrete examples of correct and incorrect patterns\n- [ ] Is structured from most to least important information\n- [ ] Could be correctly applied by someone with limited attention\n- [ ] Would be triggered by the correct glob patterns\n\n## Anti-patterns\n\n- **Verbose Introductions**: Don't waste words explaining the rule exists\n- **Duplicate Content**: Never repeat information found in other rules\n- **Vague Descriptions**: Avoid general terms like \"best practices\" without specifics\n- **Nested Complexity**: Keep rule structure flat and scannable\n- **Excessive Context**: Focus on directives, not background information\n- **Mixed Concerns**: Each rule should govern exactly one area of concern" >> .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % 

```

---

```bash
head -n 10 .cursor/rules/rule-creation-guidelines.mdc
```

```
edobry@linkslate minsky % head -n 10 .cursor/rules/rule-creation-guidelines.mdc
---
description: Guidelines for creating or updating .mdc rule files. REQUIRED when writing, modifying, or revie
wing any cursor rule.
globs: ["**/*.mdc"]
alwaysApply: false
---

# Cursor Rule Creation Guidelines

Rules are read by AI assistants with limited attention spans and context windows. Every word must count.

edobry@linkslate minsky %
```

---

The rule has been successfully created with the proper YAML frontmatter and content. The rule now provides comprehensive guidelines for creating cursor rules in the project, emphasizing concision, clarity, and effectiveness from a rule follower's perspective.

The file `.cursor/rules/rule-creation-guidelines.mdc` includes:
- A proper YAML frontmatter section with description, globs, and alwaysApply settings
- Guidelines for rule structure and content organization
- Emphasis on file location requirements
- Detailed advice for writing effective description fields
- A checklist for rule assessment
- Anti-patterns to avoid

This rule will help ensure consistency and clarity in all cursor rules created in the project.

---

_**User**_

make sure the rule mentions that the description doesnt need to include the instructions, only the situation in which the rule is relevant

---

_**Assistant**_



---

Let me update the rule to clarify this important point:

---

```diff
  The description is **critically important** as it's the main trigger for rule application:
  
+ - Focus ONLY on WHEN the rule applies, not WHAT the rule instructs
  - Begin with "Use when..." or "Guidelines for..." to clearly state when the rule applies
  - Include all relevant trigger keywords (e.g., "required for testing components")
```

---

I've updated the rule to clarify that descriptions should focus only on when the rule applies, not what the rule instructs. This is an important distinction that will help keep descriptions concise and focused on their primary purpose - correctly triggering the rule in relevant situations.

The added point emphasizes that the description field should strictly define the context for when the rule applies, not repeat the rule's instructions (which are contained in the body of the rule itself). This helps keep the descriptions concise and makes it easier for the AI to quickly determine which rules are relevant to the current task.

---

