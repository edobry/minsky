---
description: REQUIRED workflow for BOTH querying and implementing tasks - ANY interaction with tasks/sessions (viewing lists, checking status, or making changes) MUST use Minsky CLI, not file system.
globs:
alwaysApply: false
---
# Minsky Workflow

⛔️ **STOP - READ THIS FIRST**

## CLI Usage Enforcement (Critical)

**For all user-facing Minsky operations (task/session management, status, etc.), you MUST use the globally installed `minsky` CLI (available on your PATH, typically via `bun link`).**

- Example:
  ```bash
  minsky tasks list --json
  minsky session start --task 001
  minsky tasks status get '#001'
  ```
- **Do NOT use `bun run ...` or direct script execution for these operations.**
- Only use `bun run ...` or direct script execution when developing or testing the Minsky CLI itself (i.e., when working on the implementation of Minsky, not when using it as a tool).

**VERIFICATION CHECKPOINT: Before running ANY minsky CLI command, you MUST:**
- **Explicitly check the subcommand spelling against the documented command reference or by running `minsky --help` or `minsky <command> --help`.**
- **If there is ANY uncertainty about the command or its options, run the relevant `--help` command FIRST.**
- **NEVER guess subcommand names or options.**
- **If you use the wrong subcommand, treat this as a process error and immediately correct it.**

## Mandatory Session Creation

**NO IMPLEMENTATION WORK CAN BEGIN WITHOUT AN ACTIVE SESSION**

Before implementing ANY task or making ANY code changes, you MUST:

```bash
# 1. Check task status
minsky tasks status get '#XXX'

# 2. Create or verify session exists
minsky session start --task XXX

# 3. Enter session directory
cd $(minsky session dir task#XXX)
```

❌ If these steps are not completed:
- DO NOT make any code changes
- DO NOT commit any files
- DO NOT proceed with implementation

✅ These activities are allowed without a session:
- Reading code
- Searching the codebase
- Investigating issues
- Planning implementation
- Creating new task specifications

This is a HARD REQUIREMENT for all implementation work. There are NO EXCEPTIONS.

⚠️ **CRITICAL: ALL TASK AND SESSION QUERIES MUST USE THE MINSKY CLI**
⚠️ **CRITICAL: ALL COMMITS MUST BE PUSHED IMMEDIATELY**

This rule defines the comprehensive process for working with tasks and sessions using the Minsky tool. ANY operation related to tasks or sessions - whether viewing, querying, or modifying - MUST use the Minsky CLI to ensure data consistency and accuracy.

## Core Principles

1. **Always Use Minsky CLI for Task/Session Data**
   - NEVER use file listings or static documentation
   - NEVER directly manipulate Minsky's state files or databases
   - NEVER delete or modify files in `~/.local/state/minsky/`
   - NEVER read or write to `session-db.json` directly - this is STRICTLY FORBIDDEN
   - ALWAYS use appropriate minsky commands (see Command Reference section below)
   - **Do NOT use `bun run ...` for these operations.**
   - Only use `bun run ...` or direct script execution when developing or testing the Minsky CLI itself.

2. **Data Integrity is Critical**
   - Minsky maintains critical state in `~/.local/state/minsky/`
   - Direct manipulation of these files will corrupt the system
   - NEVER attempt to "fix" issues by deleting state files
   - NEVER attempt to read or modify the session database directly
   - If encountering session/task issues, use the appropriate CLI commands in the Command Reference
   - Deleting state files is STRICTLY FORBIDDEN as it:
     - Corrupts Minsky's understanding of tasks and sessions
     - Makes session management impossible
     - May lead to lost work or inconsistent state
     - Violates the core principle of CLI-based management

3. **Real-Time Data Over Static Files**
   - Task information comes from the live system, not files
   - Session state must be queried through CLI, not assumed
   - File system should never be used as a primary data source

## Command Reference

**⚠️ IMPORTANT: NEVER GUESS COMMAND NAMES OR OPTIONS**

Always use `minsky <command> --help` when you are uncertain about any command or its options. Guessing command names (like `info`, `show`, etc.) that don't exist will only result in errors and wasted time.

### Task Commands

```bash
# List all tasks
minsky tasks list [options]
  --all            # Include completed tasks (default: only active tasks)
  --json           # Output in JSON format

# Get details about a specific task
minsky tasks get <task-id> [options]
  --json           # Output in JSON format

# Task status operations
minsky tasks status
  get <task-id>    # Get the status of a task
  set <task-id> <status>  # Set task status (TODO, IN-PROGRESS, IN-REVIEW, DONE)
    --session <session>   # Session name to use for repo resolution
    --repo <repoPath>     # Path to a git repository (overrides session)

# Create a new task from a specification document
minsky tasks create <spec-path> [options]
```

### Session Commands

```bash
# List all sessions
minsky session list [options]
  --json           # Output in JSON format

# Get session details
minsky session get <session-name> [options]
  --task <task-id> # Get session by task ID instead of name
  --json           # Output in JSON format

# Start a new session (ALWAYS use with --quiet)
minsky session start [name] [options]
  --task <task-id> # Associate session with a task
  --repo <repo>    # Path or URL to repository
  --quiet          # MANDATORY: Only output session directory path

# Get session directory path
minsky session dir <session-name-or-task#id>

# Delete a session
minsky session delete <session-name> [options]
  --force          # Skip confirmation prompt
  --task <task-id> # Delete session by task ID
```

### Git Commands

```bash
# Create a PR from current branch
minsky git pr [options]
  --path <path>    # Path to repository

# Stage, commit, and optionally push all changes for a session
minsky session commit [session] [options]
  --message <msg>  # Commit message
  --no-push        # Skip pushing changes after commit
  --repo <path>    # Repository path (if not in a session or to override)

# Push changes to remote
# DEPRECATED: Prefer `minsky session commit` which includes push functionality
minsky git push
```

### Common Parameters

Several commands accept these common parameters:
- `--repo <path>`: Specify repository path (overrides session)
- `--session <name>`: Use specific session for repo resolution
- `--workspace <path>`: Specify workspace path (overrides repo and session)
- `--backend <type>`: Specify task backend (markdown, github)

Always check specific command help with `minsky <command> --help` for the most accurate and up-to-date information.

## CRITICAL REQUIREMENT: Adherence to Session-First Workflow

**⚠️ IMPORTANT: A MINSKY SESSION MUST BE ACTIVE AND ALL WORK MUST OCCUR WITHIN IT.**

Before ANY examination or modification of code, tests, or related files for a task, you **MUST**:

1.  **Verify Task Status:** Use `minsky tasks status get '#<task-id>'`.
2.  **Start or Re-enter Session:** Use `minsky session start --task <task-id> --quiet` (for new/unknown sessions) or `minsky session get --task <task-id>` (to find existing) followed by `cd $(minsky session dir <session-name-or-task#id>)`.
3.  **Confirm You Are in the Session Directory:** Use `pwd` and verify the path matches the expected Minsky session path.

**No code examination or changes are permitted until these steps are complete and you are operating within the correct session directory.**

**For comprehensive rules on how to correctly work with files (including path resolution, `edit_file` tool usage, and maintaining isolation) once inside the session workspace, you MUST refer to and strictly follow the `@session-first-workflow.mdc` rule.**

Violating this core principle of working exclusively within the Minsky session for all task-related changes compromises the entire workflow system, risks data corruption, and makes changes untraceable.

## ⚠️ REPOSITORY ISOLATION WARNING

**The session directory contains a COMPLETELY SEPARATE CLONE of the repository.**

- Changes made to files in the main workspace WILL NOT appear in the session branch
- Changes made to files in the session directory DO NOT affect the main workspace
- Always confirm your current working directory with `pwd` before making any changes
- Session isolation is fundamental to the Minsky model and must be preserved

## FILE CHANGE VERIFICATION

After every file edit in a session directory, verify the changes are actually present by:

1. Running `git status` to confirm the file appears as modified
2. Running `git diff <filename>` to confirm the expected changes exist
3. Never assuming an edit succeeded without verification

## Request Interpretation and Workflow Priority

1. **Always interpret requests based on their literal meaning in the project context.**
   - For detailed guidance on interpreting requests related to task creation, including the distinction between task specification and implementation, refer to the `@creating-tasks.mdc` rule.
   - "Implement" or "code" generally refers to writing the actual implementation for an existing, specified task.

2. **Request Type Recognition**
   - Categorize requests as either "specifying work" or "implementing work"
   - Each category requires different response patterns:
     - Specifying work → create task specification documents
     - Implementing work → write code following existing specifications
   - Never implement code until the specification is verified

3. **When to Request Clarification**
   - If a request could be interpreted multiple ways, ask for clarification
   - Examples of ambiguous requests requiring clarification:
     - "Work on task #123" (specify or implement?)
     - "Handle the task creation feature" (create spec or code?)
     - "Add the minsky task create command" (create spec or implement?)
   - Always err on the side of creating task specifications when unclear

4. **Clear vs. Ambiguous Request Examples**
   - Clear Specification Request: "Create a task to add a minsky task create command"
     → Create a task specification document
   - Clear Implementation Request: "Implement the minsky task create command according to task #007"
     → Implement the code following the specification
   - Ambiguous Request: "Add the minsky task create command"
     → Default to creating a task specification unless context clearly indicates implementation

**Automation Directive:** Whenever you are asked about the current state of tasks, sessions, or any live project data, always run the appropriate `minsky` CLI command (e.g., `minsky tasks list --json`, `minsky tasks status get <id>`, etc.) to retrieve real-time information. Do not rely solely on static documentation, code, or cached data for these queries. Only supplement with documentation or codebase details if the CLI output is insufficient or ambiguous. This ensures all answers reflect the actual, current state of the project.

## Task Selection and Initial Setup

When asked to work on a task (by name, description, or ID):

1. **Find or Access the Task**
   - For a known task ID (e.g., "001" or "#001"): Use `minsky tasks get '<task-id>' --json`
   - For finding tasks in the backlog: Use `minsky tasks list --json`
   - See the Command Reference section for complete command options
   - **Note:** Always use `jq` for JSON parsing, not `grep`. This is a general best practice for all projects.

2. **Check Task Status**
   - Before starting work: Use `minsky tasks status get '#<task-id>'`
   - For verification of implementation state versus tracked status, refer to the `@task-status-verification.mdc` protocol
   - Task status meanings:
     - `TODO`: Not started, available to work on
     - `IN-PROGRESS`: Work has begun but is not complete
     - `IN-REVIEW`: Work is complete and awaiting review
     - `DONE`: Work is complete, reviewed, and merged
   - If the task is already marked as `DONE` or `IN-REVIEW`, confirm with the user before proceeding.

3. **Understand Requirements**
   - Read the task specification document shown in the output of `minsky tasks get`
   - The path is typically `process/tasks/<task-id>-<task-name>.md` (e.g., `process/tasks/001-update-session-start.md`)
   - Ensure all requirements and acceptance criteria are clearly understood
   - Note any dependencies or blocking issues

## Creating New Tasks

When asked to create a new task:

1. **Refer to the creating-tasks rule**
   - See detailed instructions in the `creating-tasks.mdc` rule
   - Never implement code when asked to create a task unless explicitly instructed
   - Always create a well-formatted task specification document

2. **Checklist Steps for Task Creation**
   - Create a task specification document following the standardized format
   - Add the task to the main task list in `/process/tasks.md`
   - Use the next available task ID
   - Link the task correctly following project conventions

## Managing AI Rules

When working with project AI rules:

1. **Always use the Minsky CLI**
   - Use `minsky rules list` to view existing rules
   - Use `minsky rules get <rule-id>` to inspect a specific rule
   - Use `minsky rules create` to create new rules (interactive mode preferred for first-time rule creators)
   - Use `minsky rules update <rule-id>` to modify existing rules
   - Use `minsky rules search <query>` to find relevant rules

2. **Follow Rule Creation Guidelines**
   - Refer to the `rule-creation-guidelines.mdc` rule for standards
   - Follow the `rules-management.mdc` rule for command usage details
   - Ensure rules have proper metadata (description, globs, tags)
   - Place rules in the correct location (`.cursor/rules/` for Cursor AI rules)

3. **Key Operations**
   - Viewing a rule: `minsky rules get <rule-id>`
   - Updating a rule's description: `minsky rules update <rule-id> --description "New description"`
   - Searching for relevant rules: `minsky rules search "keyword"`
   - Creating a new rule: `minsky rules create` (interactive mode)
   - Listing all rules: `minsky rules list [--format cursor|generic] [--tag <tag>]`

## Session Management

### Session Creation Options

- **Session creation is flexible**
  - Sessions can be created with just a name: `minsky session start <name>`
  - Sessions can be created with a task association: `minsky session start --task <id>`
  - Task association is optional and depends on the work context

- **When to use each option**
  - Use named sessions (without tasks) for:
    - General testing/fixes
    - Exploratory work
    - Temporary changes
    - Work not associated with a specific task
  - Use task-associated sessions for:
    - Implementing a specific task
    - Work that will be tracked in the task system

- **Verification step**
  - Always verify the appropriate session creation approach based on the work context
  - Never assume a task ID is required when a simple named session would suffice

### Starting a New Session

1. **Create a Task Session (Using --quiet is MANDATORY)**
   - The `minsky session start` command **MUST ALWAYS** be used with the `--quiet` option (see Command Reference)
   - The `--quiet` option ensures consistent output of only the session directory path, critical for scripting and clear output
   - **Capturing the Session Path:** The standard and correct way to start a session and navigate into its directory is:
     ```bash
     # STANDARD USAGE: Capture path and navigate
     SESSION_DIR=$(minsky session start --task 001 --quiet)
     cd "$SESSION_DIR"
     echo "Working in session directory: $SESSION_DIR"
     ```
   - For detailed information about a session after creation, use `minsky session get` (see Command Reference)

2. **Enter the Session Directory**
   - After creating a session, navigate to the session directory (e.g., `cd "$SESSION_DIR"`)

### Re-entering an Existing Session

When asked to continue working on a task:

1. **Find Existing Session**
   - Look up the session associated with the task using `minsky session get` (see Command Reference)
   - If needed, list all sessions using `minsky session list --json`

2. **Enter Existing Session**
   - Navigate to the session directory: `cd $(minsky session dir <session-or-task-id>)`
   - If no session exists, create one as described in "Starting a New Session"

## Session Cleanup Procedures

When a task is completed and merged into the main branch:

1. **Update Task Status**
   - Always mark the task as completed:
     ```bash
     minsky tasks status set '#001' DONE
     ```
   - Verify the status update was successful:
     ```bash
     minsky tasks status get '#001'
     ```

2. **Delete the Session**
   - Always use the Minsky CLI to delete the session:
     ```bash
     minsky session delete task#001
     ```
   - If confirmation is required and you're in a script, use the `--force` flag:
     ```bash
     minsky session delete task#001 --force
     ```
   - Verify the session was deleted:
     ```bash
     minsky session get task#001
     # Should return an error if deletion was successful
     ```

3. **NEVER Manually Delete Session Data**
   - NEVER manually delete session directories
   - NEVER directly manipulate files in `~/.local/state/minsky/`
   - NEVER use `rm -rf` or similar commands to delete session data
   - Always rely on the Minsky CLI for session management

4. **Cleanup Verification**
   - After session deletion, verify:
     - The session no longer appears in `minsky session list`
     - The task is marked as DONE in `minsky tasks status get '#001'`
     - Any associated branches have been deleted or merged

## Implementation Process

1. **Planning**
   - Review the task document to ensure full understanding
   - For a new task, draft an implementation plan and append it to the task document
   - For continuing work, review the task's "Work Log" section to see progress

2. **Implementation**
   - Follow all project coding standards and best practices
   - Implement the required changes, addressing all requirements
   - Commit changes at logical intervals with clear, descriptive messages
   - Reference the task ID in all commit messages (e.g., "task#001: Implement feature X")
   - **ALWAYS push immediately after committing:**
     ```bash
     # After every commit, immediately push to the session branch
     minsky git push
     ```
   - Never leave commits unpushed at the end of an implementation session

3. **Work Log**
   - Maintain a "Work Log" section in the task document:
     ```markdown
     ## Work Log
     - YYYY-MM-DD: Implemented X feature
     - YYYY-MM-DD: Fixed Y bug
     - YYYY-MM-DD: Added tests for Z functionality
     ```
   - This log will be used to update the changelog when the task is complete

4. **Testing**
   - Write appropriate tests for all new functionality
   - Ensure all existing tests continue to pass
   - Document any complex test scenarios or edge cases addressed

## Verification and Documentation

1. **Verification**
   - Verify that all requirements have been implemented correctly
   - Check off completed verification steps in the task document by changing `[ ]` to `[x]`
   - Ensure that all tests pass

2. **Documentation**
   - Update the task document with implementation details
   - Document any design decisions or compromises made during implementation
   - Update any relevant project documentation

3. **Changelog**
   - Follow the instructions in the [changelog rule](mdc:changelog.mdc) for updating the appropriate CHANGELOG.md
   - Use the Work Log from the task document as the basis for changelog entries
   - Reference the task ID in the changelog entry

## Task Completion Checklist

Task implementation is not complete until ALL these steps are performed, in order:

1. ✓ All code changes are made in the session directory (not main workspace)
2. ✓ All tests pass in the session directory
3. ✓ Task document is updated with Work Log and verification steps are checked off
4. ✓ All changes are committed with task ID in commit message
5. ✓ PR description is generated using `minsky git pr` and saved to `process/tasks/<task-id>/pr.md`
6. ✓ PR description is committed
7. ✓ Changes are pushed to remote with `minsky git push`
8. ✓ Task status is updated to IN-REVIEW using `minsky tasks status set '#id' IN-REVIEW`

## PR Preparation

1. **Generate a PR description:**
   ```bash
   minsky git pr --path .
   ```
   - Minsky will automatically generate a PR description based on the changes in the current branch
   - Save this description to:
     ```
     process/tasks/<task-id>/pr.md
     ```
   - **For guidelines on the content and formatting of the PR description itself, refer to the `@pr-description-guidelines.mdc` rule.**
   - Commit this PR description file

2. **Finalization**
   - Push your branch:
     ```bash
     # Current approach (standard git command)
     minsky git push

     # Future: Will be simplified with dedicated command (Task #005)
     # minsky git push
     ```
   - Note: Task #005 is in progress to simplify this step with a dedicated command

3. **Status Update**
   - Update the task status to the appropriate state:
     ```bash
     # Use IN-REVIEW after you've generated a PR and pushed your changes
     minsky tasks status set '#001' IN-REVIEW

     # Use DONE only after the changes have been reviewed and merged
     minsky tasks status set '#001' DONE
     ```

## Important Notes

- Never skip verification steps or mark a task complete without meeting all requirements
- Always check the existing task status before beginning work
- Reference the task number in all PRs, commits, and documentation
- Maintain a Work Log in the task document to track implementation progress
- If modifications to the requirements are needed, discuss and document them in the task document
- When a task spans multiple sessions, use the Work Log to ensure continuity
- Minsky manages branch names, session directories, and other infrastructure—you don't need to create these manually

> **Triggering the Minsky CLI for Task/Session Queries**
>
> For any user query that asks about the existence, availability, status, or list of tasks or sessions, you MUST use the minsky CLI to retrieve live data. This includes, but is not limited to, queries such as:
> - "What tasks are available?"
> - "List all tasks"
> - "Show open/in-progress/done tasks"
> - "What sessions exist?"
> - "What is the status of task #007?"
> - "Which tasks are in the backlog?"
>
> **Do NOT** answer these queries by listing files or reading static documentation. **Always** run the appropriate minsky CLI command (e.g., `minsky tasks list --json`) and present the output directly.

## Standard Session Navigation Pattern

**ALWAYS use this exact pattern for starting sessions and navigating to them, adhering to the mandatory `--quiet` rule for `minsky session start`:**

```bash
# REQUIRED pattern for ALL session navigation
# This relies on `minsky session start --task <id> --quiet` outputting ONLY the path.
SESSION_DIR=$(minsky session start --task <id> --quiet)
cd "$SESSION_DIR"
```

This pattern **MUST** be used for reliable session creation and navigation because:
- It correctly applies the **mandatory `--quiet` flag** for `minsky session start`.
- It ensures `SESSION_DIR` accurately captures only the directory path.

Using any other approach for capturing the session path after creation is prone to errors if the `--quiet` flag is inadvertently omitted.

## Task Status Update Protocol

- All changes to task status (e.g., marking a task as DONE) must be performed using the `minsky tasks` command.
- Direct edits to `tasks.md` are strictly forbidden for status changes.
- **Verification Checkpoint:** Before marking any task as complete, verify that the update is performed via the CLI, not by file edit.
- Example:
  - Correct: `minsky tasks status set 039 DONE --session task#039`
  - Incorrect: Editing `tasks.md` directly in any workspace.

## Best Practices Cross-Reference
- See also: domain-oriented-modules, tests, dont-ignore-errors, session-first-workflow, rule-map.mdc
- This rule governs: interface alignment, batch verification, progress logging, changelog, and verification checkpoints.

## Requirements (Revised)
- You MUST update the changelog and reference SpecStory artifacts after each major milestone or batch of changes.
- You MUST maintain a running log of what was fixed, what remains, and any tool limitations or workarounds.
- You MUST use batch verification (lint, type check, test) after each set of related changes.
- You MUST confirm all changes are present in the session workspace and not the main workspace before merging or marking a task complete.
- You MUST reference this rule when planning, logging, or verifying workflow steps.

## Task Implementation and Committing

5.  **Implement and Commit**
    - Work on the task within the session directory.
    - Commit changes at logical intervals using `minsky session commit`.
      ```bash
      # Example:
      minsky session commit -m "Implement feature X for task #XXX"
      # Or, if you want to commit without pushing yet:
      minsky session commit -m "Partial implementation of Y" --no-push
      ```
    - This command will stage all changes, commit them with your message (prefixed with the task ID if available), and push by default.
    - **Verify changes with `git status` and `git diff` before committing.**

6.  **Prepare PR Description**
    - Once implementation is complete and all changes are committed (and pushed, unless intentionally deferred):
    - Generate a PR description:
      ```bash
      minsky git pr
      ```

7.  **Push and Mark In Review**
    - Ensure all changes are pushed. If you used `--no-push` with `minsky session commit` for intermediate commits, run it one last time without `--no-push` or use `git push origin <branch-name>`.
    - A simple `minsky session commit` (if you have a final commit to make) or `git push origin <branch-name>` will suffice.
    - Set the task status to in review:
      ```bash
      minsky task status set <task-id> IN-REVIEW
      ```

---
