# Bun Test Patterns

## ALWAYS USE CENTRALIZED MOCKING UTILITIES

**CRITICAL REQUIREMENT: Always use the project's centralized mocking utilities in `src/utils/test-utils/mocking.ts` instead of directly using bun:test APIs.**

```typescript
// ❌ NEVER USE DIRECT BUN:TEST APIs
import { jest, mock } from "bun:test";
const mockFn = jest.fn();
mock.module("../path/to/module", () => ({ ... }));

// ✅ ALWAYS USE CENTRALIZED UTILITIES
import { createMock, mockModule, setupTestMocks } from "../utils/test-utils/mocking";
import { createMockLogger, clearLoggerMocks } from "../utils/test-utils/logger-mock";
setupTestMocks();
const mockFn = createMock();
const mockLog = createMockLogger();
mockModule("../../../src/path/to/module", () => ({ ... }));
```

The centralized utilities provide:
1. Consistent mocking patterns across the codebase
2. Automatic mock cleanup in afterEach hooks
3. Better type safety and error handling
4. Additional helper methods for common testing scenarios
5. **Centralized logger mocking** - Prevents "log.cli is not a function" errors

## Core Mocking Utilities

### Required Setup (Updated for Task #270 Architecture)

Always begin your test file with proper import paths based on test location:

```typescript
import { describe, test, expect } from "bun:test";
import {
  createMock,
  mockModule,
  setupTestMocks,
  createMockFileSystem
} from "../utils/test-utils/mocking";
import { createMockLogger } from "../utils/test-utils/logger-mock";

// Set up automatic mock cleanup
setupTestMocks();
```

### Function Mocking

**REQUIRED: Use createMock() instead of jest.fn()**

```typescript
// ❌ INCORRECT - Direct jest API usage
const mockFunction = jest.fn().mockReturnValue("result");

// ✅ CORRECT - Using centralized utility
const mockFunction = createMock(() => "default value");
mockFunction.mockReturnValue("result");

// Assertion examples
expect(mockFunction).toHaveBeenCalled();
expect(mockFunction).toHaveBeenCalledWith("arg");
expect(mockFunction.mock.calls.length).toBe(1);
```

### Module Mocking (Updated Paths for New Architecture)

**REQUIRED: Use mockModule() with proper src/ prefix**

```typescript
// ❌ INCORRECT - Direct mock API usage or wrong paths
mock.module("../path/to/module", () => ({
  exportedFunction: jest.fn()
}));

// ✅ CORRECT - Using centralized utility with src/ prefix
mockModule("../../../src/domain/tasks", () => ({
  getTaskFromParams: createMock(),
  setTaskStatusFromParams: createMock()
}));

// ✅ CORRECT - From adapter tests
mockModule("../../../../src/adapters/shared/commands/tasks", () => ({
  registerTasksCommands: createMock()
}));
```

### Logger Mocking

**REQUIRED: Use createMockLogger() to prevent "log.cli is not a function" errors**

```typescript
// ❌ INCORRECT - Incomplete logger mock
const mockLog = {
  debug: jest.fn(),
  info: jest.fn()
  // Missing cli, agent, and other methods
};

// ✅ CORRECT - Using centralized logger mock
import { createMockLogger } from "../utils/test-utils/logger-mock";

const mockLog = createMockLogger();

// Mock the logger module
mockModule("../../../src/utils/logger", () => ({
  log: mockLog
}));

// Now all logger methods are available
expect(mockLog.cli).toHaveBeenCalledWith("CLI message");
expect(mockLog.debug).toHaveBeenCalledWith("Debug message");
expect(mockLog.agent).toHaveBeenCalledWith("Agent message");
```

### Filesystem Mocking

**REQUIRED: Use createMockFileSystem() for all filesystem operations**

```typescript
// ❌ INCORRECT - Testing actual filesystem
test("saves config to file", () => {
  saveConfig({ setting: true });
  expect(fs.existsSync(CONFIG_PATH)).toBe(true);
});

// ✅ CORRECT - Using mock filesystem
test("saves config to file", () => {
  const mockFS = createMockFileSystem();
  mockModule("fs", () => mockFS);

  saveConfig({ setting: true });

  expect(mockFS.written[CONFIG_PATH]).toBeDefined();
});
```

## Test Organization Patterns (Updated for Task #270)

### Domain Command Test Structure

```typescript
// src/domain/tasks.commands.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { createMock, mockModule, setupTestMocks } from "../utils/test-utils/mocking";

// Set up automatic mock cleanup
setupTestMocks();

// Mock domain services that the commands use
const mockTaskService = createMock();
mockModule("../../../src/domain/tasks/taskService", () => ({
  getTask: mockTaskService
}));

describe("Task Domain Commands", () => {
  beforeEach(() => {
    mockTaskService.mockReset();
  });

  describe("getTaskFromParams", () => {
    test("should validate and retrieve task", async () => {
      // Arrange
      const params = { id: "123" };
      const expectedTask = { id: "123", title: "Test Task" };
      mockTaskService.mockResolvedValue(expectedTask);

      // Act
      const result = await getTaskFromParams(params);

      // Assert
      expect(result).toEqual(expectedTask);
      expect(mockTaskService).toHaveBeenCalledWith("123");
    });
  });
});
```

### Adapter Test Structure

```typescript
// src/adapters/shared/tasks.adapter.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { createMock, setupTestMocks } from "../../utils/test-utils/mocking";
import { registerTasksCommands } from "../../../../src/adapters/shared/commands/tasks";

// Set up automatic mock cleanup
setupTestMocks();

describe("Shared Tasks Adapter", () => {
  test("registers correct number of commands", () => {
    // Arrange
    const mockRegistry = {
      commands: new Map(),
      register: createMock()
    };

    // Act
    registerTasksCommands(mockRegistry);

    // Assert
    expect(mockRegistry.register).toHaveBeenCalledTimes(7);
  });
});
```

### Test Suite Structure

Organize tests with appropriate nesting and descriptive names:

```typescript
describe("Module name", () => {
  describe("functionName", () => {
    test("should handle specific input correctly", () => {
      // Test content
    });

    test("should throw error for invalid input", () => {
      // Test content
    });
  });
});
```

### Test Isolation

Ensure tests don't share mutable state:

```typescript
describe("Module with state", () => {
  let instance;

  beforeEach(() => {
    // Create a fresh instance for each test
    instance = createTestInstance();
  });

  afterEach(() => {
    // Clean up after each test
    instance.cleanup();
  });

  test("should modify state correctly", () => {
    instance.performAction();
    expect(instance.state).toBe("expected");
  });
});
```

## Common Test Patterns

### Arrange-Act-Assert Pattern

Structure tests using the AAA pattern:

```typescript
test("function should transform input correctly", () => {
  // Arrange
  const input = { data: "input" };
  const expectedOutput = { data: "transformed" };

  // Act
  const result = transformFunction(input);

  // Assert
  expect(result).toEqual(expectedOutput);
});
```

### Testing Asynchronous Code

```typescript
test("async function returns expected result", async () => {
  // Arrange
  const mockData = { id: 123 };
  const mockApi = createMock();
  mockApi.mockResolvedValue(mockData);
  mockModule("../../../src/api", () => ({ fetchData: mockApi }));

  // Act
  const result = await fetchAndProcess(123);

  // Assert
  expect(mockApi).toHaveBeenCalledWith(123);
  expect(result).toEqual(expect.objectContaining({ id: 123, processed: true }));
});
```

### Testing Error Cases

```typescript
test("function throws for invalid input", () => {
  // Arrange
  const invalidInput = null;

  // Act & Assert
  expect(() => validateInput(invalidInput)).toThrowError(/invalid input/i);
});
```

## Path Examples for New Architecture

### Import Paths by Test Location

```typescript
// From src/domain/*.commands.test.ts (co-located)
import { createMock } from "../utils/test-utils/mocking";
mockModule("./tasks", () => ({ ... }));

// From src/adapters/cli/*.adapter.test.ts (co-located)
import { createMock } from "../../utils/test-utils/mocking";
mockModule("./commands", () => ({ ... }));

// From src/adapters/shared/*.adapter.test.ts (co-located)
import { createMock } from "../../utils/test-utils/mocking";
mockModule("./commands", () => ({ ... }));

// From src/domain/*.test.ts (co-located domain service tests)
import { createMock } from "../utils/test-utils/mocking";
mockModule("./taskService", () => ({ ... }));
```

## Common Troubleshooting

### Jest vs Bun:Test Compatibility

If encountering issues with Jest compatibility:

```typescript
// Issue with bun:test not fully supporting all Jest features
// For complex mocking scenarios, use our utility wrappers:

import { createSpy } from "../utils/test-utils/mocking";

// Instead of direct spyOn
// const spy = jest.spyOn(object, 'method');

// Use our utility
const spy = createSpy(object, 'method');
```

### Fixing Mock Not Found Issues

If seeing "Mock not found" errors:

```typescript
// Issue:
// Error: Mock for "../some-module" not found

// Solution:
// 1. Make sure you're calling mockModule BEFORE importing the module under test
// 2. Use proper relative paths with src/ prefix from the test file location

// CORRECT from src/domain/ (co-located):
mockModule("./tasks", () => ({
  // mocked exports
}));

// CORRECT from src/adapters/cli/ (co-located):
mockModule("../../domain/tasks", () => ({
  // mocked exports
}));
```

## 🎯 CRITICAL SUCCESS PATTERNS (100% Success Rate)

**Discovered through systematic test fixing achieving complete test success**

### 1. **Explicit Mock Pattern** (CRITICAL SUCCESS FACTOR)

**Problem**: Factory-generated mocks with async functions are unreliable
**Success Rate**: 100% when applied correctly

```typescript
// ❌ UNRELIABLE: Factory-generated mock
const mockService = createMockService(async (id) => {
  if (id === "test") return mockData;
  return null;
});

// ✅ RELIABLE: Explicit Mock Pattern
const mockService = {
  getData: async (id: string) => {
    if (id === "test") {
      return { id: "test", name: "Test Item" };
    }
    return null;
  },
  listItems: async () => [],
  updateItem: async () => {},
  deleteItem: async () => false,
  // All methods explicitly defined
};
```

**Key Benefits**:
- ✅ Reliable mock construction
- ✅ All required methods explicitly defined
- ✅ Handles both input and qualified ID formats
- ✅ Predictable behavior

### 2. **Template Literal Pattern** (CRITICAL SUCCESS FACTOR)

**Problem**: Repeated string construction leads to format mismatches and maintenance burden
**Success Rate**: 100% for eliminating magic string errors

```typescript
// ❌ PROBLEMATIC: Magic strings and repetition
expect(result.id).toBe("user-123");
expect(result.name).toBe("user-123-session");
expect(commands).toContain("process user-123 for session user-123-session");

// ✅ RELIABLE: Template Literal Pattern with extracted constants
const USER_ID = "123";
const QUALIFIED_ID = `user-${USER_ID}`;
const SESSION_NAME = `${QUALIFIED_ID}-session`;
const COMMAND = `process ${QUALIFIED_ID} for session ${SESSION_NAME}`;

expect(result.id).toBe(QUALIFIED_ID);
expect(result.name).toBe(SESSION_NAME);
expect(commands).toContain(COMMAND);
```

**Key Benefits**:
- ✅ Single source of truth for each identifier
- ✅ Reduced surface area for errors
- ✅ Easier maintenance and refactoring
- ✅ Consistent format across all usages

### 3. **Format Alignment Pattern** (BREAKTHROUGH DISCOVERY)

**Problem**: Mock data format doesn't match system-generated formats
**Success Rate**: 100% for format-related test failures

```typescript
// ❌ MISALIGNED: Mock format doesn't match system format
const mockDatabase = {
  getRecord: (id: string) => Promise.resolve({
    name: `item${id}`, // → "item123" (no separator) ❌
    path: `data/item${id}`, // → "data/item123" (inconsistent) ❌
  })
};

// ✅ ALIGNED: Mock format matches system format
const mockDatabase = {
  getRecord: (id: string) => Promise.resolve({
    name: `item-${id}`, // → "item-123" (with separator) ✅
    path: `data/item-${id}`, // → "data/item-123" (consistent) ✅
  })
};
```

**Critical Discovery**: Mock data must exactly match real system output formats
**Fix Approach**: Ensure both system code AND test mocks use identical formatting

### 4. **Cross-Test Interference Prevention** (CRITICAL DISCOVERY)

**Problem**: Global `mock.module()` calls persist across tests causing interference
**Root Cause**: Tests passing in isolation but failing in full suite

```typescript
// ❌ DANGEROUS: Global module mocks that persist
mock.module("../utils/logger", () => ({
  log: mockLog,
}));
mock.module("../utils/database", () => ({
  query: mock(() => Promise.resolve({})),
}));

// ✅ SAFE: Use dependency injection instead
const dependencies = {
  logger: mockLogger,
  database: mockDatabase,
  service: mockService,
  utils: mockUtils,
};
```

**Key Discovery**: Functions that import mocked modules fail when other tests globally mock those same modules.

**Solution**: Remove global module mocks, use dependency injection pattern.

### 5. **Domain Functions vs CLI Execution** (ARCHITECTURAL PRINCIPLE)

**Problem**: Tests executing CLI processes instead of testing domain logic
**Anti-Pattern**: Process spawning in unit tests

```typescript
// ❌ WRONG: Testing CLI interface
const { stdout, stderr } = await execAsync('bun run ./src/cli.ts command --id=123');
expect(stdout).toContain("123");

// ✅ CORRECT: Testing domain logic
const result = await processCommand("123", { service: mockService });
expect(result.id).toBe("123");
```

**Key Benefits**:
- ✅ Fast execution (no process spawning)
- ✅ Reliable isolation (proper dependency injection)
- ✅ Focused testing (business logic vs CLI interface)
- ✅ Better error messages and debugging

### 6. **Testable Design Pattern** (ARCHITECTURAL IMPROVEMENT)

**Problem**: Complex functions with I/O operations are hard to unit test
**Solution**: Extract pure business logic for focused unit testing

```typescript
// ❌ COMPLEX: Function with mixed concerns
async function processData(params, deps) {
  // Complex I/O operations, business logic, notifications, etc.
  if (!params.skipValidation && hasErrors) {
    await validationService.validate();
  }
  if (!params.skipNotification) {
    await notificationService.send();
  }
}

// ✅ EXTRACTED: Pure business logic functions
export function shouldValidate(options, state) {
  if (options.force) return false;
  if (options.skipValidation) return false;
  return state.hasErrors;
}

export function shouldNotify(options) {
  return !options.skipNotification;
}
```

**Benefits**:
- ✅ Focused unit tests covering all conditional logic
- ✅ No I/O dependencies in pure function tests
- ✅ Fast execution and reliable testing
- ✅ Clear separation of concerns

## ⚠️ CRITICAL ANTI-PATTERNS TO AVOID

### 1. **Global Module Mocks** (CAUSES CROSS-TEST INTERFERENCE)
```typescript
// ❌ NEVER: Global mocks persist across tests
mock.module("../utils/logger", () => ({ ... }));
```

### 2. **CLI Execution in Tests** (ARCHITECTURAL ANTI-PATTERN)
```typescript
// ❌ NEVER: Spawn CLI processes in tests
const { stdout } = await execAsync('bun run ./src/cli.ts ...');
```

### 3. **Unreliable Mock Construction**
```typescript
// ❌ AVOID: Factory-generated mocks with complex logic - often fails
createMockService(async (id) => id === "test" ? mockData : null)
```

### 4. **Magic String Duplication**
```typescript
// ❌ AVOID: Repeated hardcoded strings
expect(result.id).toBe("item-001");
expect(errorMessage).toContain("item-001");
const name = "item-001";
```

### 5. **Format Misalignment**
```typescript
// ❌ AVOID: Mock format doesn't match system format
const mockService = {
  getItem: (id) => ({ name: `item${id}` }) // Missing separator!
};
```

### 6. **Symptom Masking vs Root Cause Investigation**
```typescript
// ❌ WRONG: Paper over with setupTestMocks()
setupTestMocks(); // Masks cross-test interference

// ✅ CORRECT: Hunt down and fix global module mocks
// Remove: mock.module("../utils/logger", ...)
```

## Benefits of Following These Patterns

1. **Proven Success**: 100% test success rate achieved through systematic approach
2. **Architectural Clarity**: Clear separation between business logic and I/O operations  
3. **Test Reliability**: No cross-test interference or isolation issues
4. **Performance**: Fast test execution with proper dependency injection
5. **Maintainability**: Template literals and explicit mocks reduce maintenance burden
6. **Debugging**: Root cause investigation over symptom masking
7. **Consistency**: All tests use the same proven patterns across the codebase
