# Bun Test Patterns

## ALWAYS USE CENTRALIZED MOCKING UTILITIES

**CRITICAL REQUIREMENT: Always use the project's centralized mocking utilities in `src/utils/test-utils/mocking.ts` instead of directly using bun:test APIs.**

```typescript
// ❌ NEVER USE DIRECT BUN:TEST APIs
import { jest, mock } from "bun:test";
const mockFn = jest.fn();
mock.module("../path/to/module", () => ({ ... }));

// ✅ ALWAYS USE CENTRALIZED UTILITIES
import { createMock, mockModule, setupTestMocks } from "../utils/test-utils/mocking";
import { createMockLogger, clearLoggerMocks } from "../utils/test-utils/logger-mock";
setupTestMocks();
const mockFn = createMock();
const mockLog = createMockLogger();
mockModule("../../../src/path/to/module", () => ({ ... }));
```

The centralized utilities provide:
1. Consistent mocking patterns across the codebase
2. Automatic mock cleanup in afterEach hooks
3. Better type safety and error handling
4. Additional helper methods for common testing scenarios
5. **Centralized logger mocking** - Prevents "log.cli is not a function" errors

## Core Mocking Utilities

### Required Setup (Updated for Task #270 Architecture)

Always begin your test file with proper import paths based on test location:

```typescript
import { describe, test, expect } from "bun:test";
import {
  createMock,
  mockModule,
  setupTestMocks,
  createMockFileSystem
} from "../utils/test-utils/mocking";
import { createMockLogger } from "../utils/test-utils/logger-mock";

// Set up automatic mock cleanup
setupTestMocks();
```

### Function Mocking

**REQUIRED: Use createMock() instead of jest.fn()**

```typescript
// ❌ INCORRECT - Direct jest API usage
const mockFunction = jest.fn().mockReturnValue("result");

// ✅ CORRECT - Using centralized utility
const mockFunction = createMock(() => "default value");
mockFunction.mockReturnValue("result");

// Assertion examples
expect(mockFunction).toHaveBeenCalled();
expect(mockFunction).toHaveBeenCalledWith("arg");
expect(mockFunction.mock.calls.length).toBe(1);
```

### Module Mocking (Updated Paths for New Architecture)

**REQUIRED: Use mockModule() with proper src/ prefix**

```typescript
// ❌ INCORRECT - Direct mock API usage or wrong paths
mock.module("../path/to/module", () => ({
  exportedFunction: jest.fn()
}));

// ✅ CORRECT - Using centralized utility with src/ prefix
mockModule("../../../src/domain/tasks", () => ({
  getTaskFromParams: createMock(),
  setTaskStatusFromParams: createMock()
}));

// ✅ CORRECT - From adapter tests
mockModule("../../../../src/adapters/shared/commands/tasks", () => ({
  registerTasksCommands: createMock()
}));
```

### Logger Mocking

**REQUIRED: Use createMockLogger() to prevent "log.cli is not a function" errors**

```typescript
// ❌ INCORRECT - Incomplete logger mock
const mockLog = {
  debug: jest.fn(),
  info: jest.fn()
  // Missing cli, agent, and other methods
};

// ✅ CORRECT - Using centralized logger mock
import { createMockLogger } from "../utils/test-utils/logger-mock";

const mockLog = createMockLogger();

// Mock the logger module
mockModule("../../../src/utils/logger", () => ({
  log: mockLog
}));

// Now all logger methods are available
expect(mockLog.cli).toHaveBeenCalledWith("CLI message");
expect(mockLog.debug).toHaveBeenCalledWith("Debug message");
expect(mockLog.agent).toHaveBeenCalledWith("Agent message");
```

### Filesystem Mocking

**REQUIRED: Use createMockFileSystem() for all filesystem operations**

```typescript
// ❌ INCORRECT - Testing actual filesystem
test("saves config to file", () => {
  saveConfig({ setting: true });
  expect(fs.existsSync(CONFIG_PATH)).toBe(true);
});

// ✅ CORRECT - Using mock filesystem
test("saves config to file", () => {
  const mockFS = createMockFileSystem();
  mockModule("fs", () => mockFS);

  saveConfig({ setting: true });

  expect(mockFS.written[CONFIG_PATH]).toBeDefined();
});
```

## Test Organization Patterns (Updated for Task #270)

### Domain Command Test Structure

```typescript
// src/domain/tasks.commands.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { createMock, mockModule, setupTestMocks } from "../utils/test-utils/mocking";

// Set up automatic mock cleanup
setupTestMocks();

// Mock domain services that the commands use
const mockTaskService = createMock();
mockModule("../../../src/domain/tasks/taskService", () => ({
  getTask: mockTaskService
}));

describe("Task Domain Commands", () => {
  beforeEach(() => {
    mockTaskService.mockReset();
  });

  describe("getTaskFromParams", () => {
    test("should validate and retrieve task", async () => {
      // Arrange
      const params = { id: "123" };
      const expectedTask = { id: "123", title: "Test Task" };
      mockTaskService.mockResolvedValue(expectedTask);

      // Act
      const result = await getTaskFromParams(params);

      // Assert
      expect(result).toEqual(expectedTask);
      expect(mockTaskService).toHaveBeenCalledWith("123");
    });
  });
});
```

### Adapter Test Structure

```typescript
// src/adapters/shared/tasks.adapter.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { createMock, setupTestMocks } from "../../utils/test-utils/mocking";
import { registerTasksCommands } from "../../../../src/adapters/shared/commands/tasks";

// Set up automatic mock cleanup
setupTestMocks();

describe("Shared Tasks Adapter", () => {
  test("registers correct number of commands", () => {
    // Arrange
    const mockRegistry = {
      commands: new Map(),
      register: createMock()
    };

    // Act
    registerTasksCommands(mockRegistry);

    // Assert
    expect(mockRegistry.register).toHaveBeenCalledTimes(7);
  });
});
```

### Test Suite Structure

Organize tests with appropriate nesting and descriptive names:

```typescript
describe("Module name", () => {
  describe("functionName", () => {
    test("should handle specific input correctly", () => {
      // Test content
    });

    test("should throw error for invalid input", () => {
      // Test content
    });
  });
});
```

### Test Isolation

Ensure tests don't share mutable state:

```typescript
describe("Module with state", () => {
  let instance;

  beforeEach(() => {
    // Create a fresh instance for each test
    instance = createTestInstance();
  });

  afterEach(() => {
    // Clean up after each test
    instance.cleanup();
  });

  test("should modify state correctly", () => {
    instance.performAction();
    expect(instance.state).toBe("expected");
  });
});
```

## Common Test Patterns

### Arrange-Act-Assert Pattern

Structure tests using the AAA pattern:

```typescript
test("function should transform input correctly", () => {
  // Arrange
  const input = { data: "input" };
  const expectedOutput = { data: "transformed" };

  // Act
  const result = transformFunction(input);

  // Assert
  expect(result).toEqual(expectedOutput);
});
```

### Testing Asynchronous Code

```typescript
test("async function returns expected result", async () => {
  // Arrange
  const mockData = { id: 123 };
  const mockApi = createMock();
  mockApi.mockResolvedValue(mockData);
  mockModule("../../../src/api", () => ({ fetchData: mockApi }));

  // Act
  const result = await fetchAndProcess(123);

  // Assert
  expect(mockApi).toHaveBeenCalledWith(123);
  expect(result).toEqual(expect.objectContaining({ id: 123, processed: true }));
});
```

### Testing Error Cases

```typescript
test("function throws for invalid input", () => {
  // Arrange
  const invalidInput = null;

  // Act & Assert
  expect(() => validateInput(invalidInput)).toThrowError(/invalid input/i);
});
```

## Path Examples for New Architecture

### Import Paths by Test Location

```typescript
// From src/domain/*.commands.test.ts (co-located)
import { createMock } from "../utils/test-utils/mocking";
mockModule("./tasks", () => ({ ... }));

// From src/adapters/cli/*.adapter.test.ts (co-located)
import { createMock } from "../../utils/test-utils/mocking";
mockModule("./commands", () => ({ ... }));

// From src/adapters/shared/*.adapter.test.ts (co-located)
import { createMock } from "../../utils/test-utils/mocking";
mockModule("./commands", () => ({ ... }));

// From src/domain/*.test.ts (co-located domain service tests)
import { createMock } from "../utils/test-utils/mocking";
mockModule("./taskService", () => ({ ... }));
```

## Common Troubleshooting

### Jest vs Bun:Test Compatibility

If encountering issues with Jest compatibility:

```typescript
// Issue with bun:test not fully supporting all Jest features
// For complex mocking scenarios, use our utility wrappers:

import { createSpy } from "../utils/test-utils/mocking";

// Instead of direct spyOn
// const spy = jest.spyOn(object, 'method');

// Use our utility
const spy = createSpy(object, 'method');
```

### Fixing Mock Not Found Issues

If seeing "Mock not found" errors:

```typescript
// Issue:
// Error: Mock for "../some-module" not found

// Solution:
// 1. Make sure you're calling mockModule BEFORE importing the module under test
// 2. Use proper relative paths with src/ prefix from the test file location

// CORRECT from src/domain/ (co-located):
mockModule("./tasks", () => ({
  // mocked exports
}));

// CORRECT from src/adapters/cli/ (co-located):
mockModule("../../domain/tasks", () => ({
  // mocked exports
}));
```

## 🎯 CRITICAL SUCCESS PATTERNS (100% Success Rate)

**Discovered through systematic test fixing achieving 100% test success rate (1458/1458 tests passing)**

### 1. **Explicit Mock Pattern** (CRITICAL SUCCESS FACTOR)

**Problem**: `createMockTaskService(async (taskId) => ...)` doesn't work properly
**Success Rate**: 100% when applied correctly

```typescript
// ❌ BROKEN: createMockTaskService approach
const mockTaskService = createMockTaskService(async (taskId) => {
  if (taskId === "155") return mockTask;
  return null;
});

// ✅ PROVEN: Explicit Mock Pattern
const mockTaskService = {
  getTask: async (taskId: string) => {
    // Handle both input and qualified formats since function normalizes IDs
    if (taskId === "155" || taskId === "md#155") {
      return { ...mockTask, id: "md#155" };
    }
    return null;
  },
  listTasks: async () => [],
  getTaskStatus: async () => undefined,
  setTaskStatus: async () => {},
  createTask: async () => ({ id: "#test", title: "Test", status: "TODO" }),
  deleteTask: async () => false,
  getWorkspacePath: () => "/test/path",
  getBackendForTask: async () => "markdown",
  createTaskFromTitleAndDescription: async () => ({ id: "#test", title: "Test", status: "TODO" }),
};
```

**Key Benefits**:
- ✅ Reliable mock construction
- ✅ All required methods explicitly defined
- ✅ Handles both input and qualified ID formats
- ✅ Predictable behavior

### 2. **Template Literal Pattern** (CRITICAL SUCCESS FACTOR)

**Problem**: Repeated string construction leads to format mismatches and maintenance burden
**Success Rate**: 100% for eliminating magic string errors

```typescript
// ❌ PROBLEMATIC: Magic strings and repetition
expect(result.taskId).toBe("md#125");
expect(result.session).toBe("task-md#125");
expect(gitCommands).toContain("git commit -m \"chore(md#125): update task status to DONE\"");
expect(gitCommands).toContain("git show-ref --verify --quiet refs/heads/pr/task-md#125");

// ✅ PROVEN: Template Literal Pattern with extracted constants
const TASK_ID = "125";
const QUALIFIED_TASK_ID = `md#${TASK_ID}`;
const SESSION_NAME = `task-${QUALIFIED_TASK_ID}`;
const PR_BRANCH = `pr/${SESSION_NAME}`;
const COMMIT_MESSAGE = `chore(${QUALIFIED_TASK_ID}): update task status to DONE`;

expect(result.taskId).toBe(QUALIFIED_TASK_ID);
expect(result.session).toBe(SESSION_NAME);
expect(gitCommands).toContain(`git commit -m "${COMMIT_MESSAGE}"`);
expect(gitCommands).toContain(`git show-ref --verify --quiet refs/heads/${PR_BRANCH}`);
```

**Key Benefits**:
- ✅ Single source of truth for each identifier
- ✅ Reduced surface area for errors
- ✅ Easier maintenance and refactoring
- ✅ Consistent format across all usages

### 3. **Session Format Alignment Pattern** (BREAKTHROUGH DISCOVERY)

**Problem**: System generates session names with dash but tests expect without dash
**Success Rate**: 100% for session-related test failures

```typescript
// ❌ BROKEN: Session DB mock returns wrong format
const mockSessionDB = {
  getSessionByTaskId: (taskId: string) => Promise.resolve({
    session: `task${taskId}`, // → "taskmd#125" (no dash) ❌
    taskId,
    prBranch: `pr/task${taskId}`, // → "pr/taskmd#125" (no dash) ❌
  })
};

// ✅ FIXED: Session DB mock returns correct format
const mockSessionDB = {
  getSessionByTaskId: (taskId: string) => Promise.resolve({
    session: `task-${taskId}`, // → "task-md#125" (with dash) ✅
    taskId,
    prBranch: `pr/task-${taskId}`, // → "pr/task-md#125" (with dash) ✅
  })
};
```

**Critical Discovery**: Session names come from database records, not just generation functions
**Fix Approach**: Fix both the actual system code AND test mocks to align on format

### 4. **Cross-Test Interference Prevention** (CRITICAL DISCOVERY)

**Problem**: Global `mock.module()` calls persist across tests causing interference
**Root Cause**: Tests passing in isolation but failing in full suite

```typescript
// ❌ DANGEROUS: Global module mocks that persist
mock.module("../utils/logger", () => ({
  log: mockLog,
}));
mock.module("../utils/exec", () => ({
  execAsync: mock(() => Promise.resolve({})),
}));

// ✅ SAFE: Use dependency injection instead
const dependencies = {
  sessionDB: mockSessionDB,
  gitService: mockGitService,
  taskService: mockTaskService,
  workspaceUtils: mockWorkspaceUtils,
};
```

**Key Discovery**: Functions that import mocked modules (`startSessionFromParams` imports `logger`, `exec`, `git-exec`) fail when other tests globally mock these modules.

**Solution**: Remove global module mocks, use dependency injection pattern.

### 5. **Domain Functions vs CLI Execution** (ARCHITECTURAL PRINCIPLE)

**Problem**: Tests executing CLI processes instead of testing domain logic
**Anti-Pattern**: `execAsync('bun run ./src/cli.ts tasks get "md#367"')`

```typescript
// ❌ WRONG: Testing CLI interface
const { stdout, stderr } = await execAsync('bun run ./src/cli.ts tasks get "md#367"');
expect(stdout).toContain("md#367");

// ✅ CORRECT: Testing domain logic
const result = await getTask("md#367", { taskService: mockTaskService });
expect(result.id).toBe("md#367");
```

**Key Benefits**:
- ✅ Fast execution (no process spawning)
- ✅ Reliable isolation (proper dependency injection)
- ✅ Focused testing (business logic vs CLI interface)
- ✅ Better error messages and debugging

### 6. **Testable Design Pattern** (ARCHITECTURAL IMPROVEMENT)

**Problem**: Complex functions with I/O operations are hard to unit test
**Solution**: Extract pure business logic for focused unit testing

```typescript
// ❌ COMPLEX: Function with mixed concerns
async function updateSessionFromParams(params, deps) {
  // Complex git operations, session logic, pushing, etc.
  if (!params.noStash && hasUncommittedChanges) {
    await gitService.stashChanges();
  }
  if (!params.noPush) {
    await gitService.push();
  }
}

// ✅ EXTRACTED: Pure business logic functions
export function shouldStashChanges(options, state) {
  if (options.force) return false;
  if (options.noStash) return false;
  return state.hasUncommittedChanges;
}

export function shouldPushChanges(options) {
  return !options.noPush;
}
```

**Benefits**:
- ✅ 21 focused unit tests covering all conditional logic
- ✅ No git dependencies in pure function tests
- ✅ Fast execution and reliable testing
- ✅ Clear separation of concerns

## ⚠️ CRITICAL ANTI-PATTERNS TO AVOID

### 1. **Global Module Mocks** (CAUSES CROSS-TEST INTERFERENCE)
```typescript
// ❌ NEVER: Global mocks persist across tests
mock.module("../utils/logger", () => ({ ... }));
```

### 2. **CLI Execution in Tests** (ARCHITECTURAL ANTI-PATTERN)
```typescript
// ❌ NEVER: Spawn CLI processes in tests
const { stdout } = await execAsync('bun run ./src/cli.ts ...');
```

### 3. **Unreliable Mock Construction**
```typescript
// ❌ AVOID: createMockTaskService with async functions - often fails
createMockTaskService(async (taskId) => taskId === "155" ? mockTask : null)
```

### 4. **Magic String Duplication**
```typescript
// ❌ AVOID: Repeated hardcoded strings
expect(result.taskId).toBe("md#001");
expect(errorMessage).toContain("md#001");
const sessionName = "task-md#001";
```

### 5. **Session Format Misalignment**
```typescript
// ❌ AVOID: Mock format doesn't match system format
const mockSessionDB = {
  getSessionByTaskId: (taskId) => ({ session: `task${taskId}` }) // Missing dash!
};
```

### 6. **Symptom Masking vs Root Cause Investigation**
```typescript
// ❌ WRONG: Paper over with setupTestMocks()
setupTestMocks(); // Masks cross-test interference

// ✅ CORRECT: Hunt down and fix global module mocks
// Remove: mock.module("../utils/logger", ...)
```

## Benefits of Following These Patterns

1. **Proven Success**: 100% test success rate (1458/1458 tests passing) achieved
2. **Architectural Clarity**: Clear separation between business logic and I/O operations  
3. **Test Reliability**: No cross-test interference or isolation issues
4. **Performance**: Fast test execution with proper dependency injection
5. **Maintainability**: Template literals and explicit mocks reduce maintenance burden
6. **Debugging**: Root cause investigation over symptom masking
7. **Consistency**: All tests use the same proven patterns across the codebase
