---
description:
globs:
alwaysApply: false
---
# Migration Safety Protocol

## Critical Error Prevention

This rule prevents the critical error that occurred in Task 209: removing essential functionality without proper verification.

**MANDATORY APPLICATION**: This rule MUST be applied before ANY operation that:
- Deletes files or removes code
- Migrates from one system to another
- Refactors by removing functionality
- Updates dependencies that change APIs
- Simplifies architecture by elimination

## ⚠️ IMMEDIATE TRIGGER CONDITIONS

**STOP and apply this protocol when encountering ANY of these phrases:**
- "remove", "delete", "eliminate"
- "migrate from X to Y"
- "replace X with Y"
- "simplify by removing"
- "no longer needed"
- "deprecated", "legacy"

## MANDATORY 3-PHASE PROTOCOL

### Phase 1: Functionality Mapping (REQUIRED BEFORE ANY DELETION)

**MUST complete ALL steps before proceeding:**

1. **Document All Exports**:
   ```bash
   grep -r "export" path/to/component/ > functionality-inventory.txt
   ```

2. **Find All Usage Locations**:
   ```bash
   grep -r "import.*from.*component" src/ > usage-locations.txt
   grep -r "component-name" src/ >> usage-locations.txt
   ```

3. **Map Dependencies**:
   - What calls each function/class?
   - What does each component provide to the system?
   - Are there implicit dependencies (config, environment)?

4. **Establish Test Baseline**:
   ```bash
   bun test > pre-migration-test-results.txt
   ```

**VERIFICATION CHECKPOINT**: If you cannot answer "What does this component do and who uses it?" for EVERY piece being removed, STOP and gather more information.

### Phase 2: Incremental Migration (NEVER REMOVE EVERYTHING AT ONCE)

**MANDATORY PROCESS:**

1. **Build New System Alongside Old**:
   - Create new implementation
   - Keep old system completely intact
   - Create compatibility adapters if needed

2. **Replace One Usage at a Time**:
   ```bash
   # After each single replacement:
   bun test
   git commit -m "Migrate component X usage in file Y"
   ```

3. **Verify Each Step**:
   - Tests must pass after each change
   - Functionality must be verified
   - No skipping verification "to save time"

**VERIFICATION CHECKPOINT**: If ANY test fails or functionality breaks, STOP and fix before proceeding.

### Phase 3: Deletion Safety (MANDATORY BEFORE REMOVING FILES)

**MUST complete ALL checks:**

1. **Zero Usage Verification**:
   ```bash
   grep -r "component-name" src/ | grep -v ".disabled" | grep -v ".backup"
   # Result MUST be empty or deletion is FORBIDDEN
   ```

2. **Create Rollback Point**:
   ```bash
   git checkout -b rollback-point-before-deletion-$(date +%Y%m%d-%H%M%S)
   git checkout main
   ```

3. **Final Functionality Test**:
   ```bash
   bun test  # MUST pass 100%
   # Run integration tests
   # Verify core workflows manually
   ```

**VERIFICATION CHECKPOINT**: If ANY usage found or ANY test fails, deletion is FORBIDDEN.

## ENFORCEMENT MECHANISMS

### Automated Checks (REQUIRED)

Before ANY file deletion, MUST run:

```typescript
// MANDATORY: verify-safe-to-delete.ts
export async function verifySafeToDelete(componentPath: string): Promise<boolean> {
  // Check for remaining imports
  const usageLocations = await findUsageLocations(componentPath);
  if (usageLocations.length > 0) {
    throw new Error(`DELETION FORBIDDEN: ${componentPath} still used in: ${usageLocations.join(', ')}`);
  }
  
  // Run tests
  const testsPass = await runTests();
  if (!testsPass) {
    throw new Error(`DELETION FORBIDDEN: tests failing`);
  }
  
  return true;
}
```

### Mandatory Pre-Action Checklist

**BEFORE any deletion operation, MUST verify:**
- [ ] Functionality inventory completed
- [ ] All usage locations identified and migrated
- [ ] Tests passing after each migration step
- [ ] Zero usage verification completed (grep results empty)
- [ ] Rollback branch created
- [ ] Final functionality verification passed

**IF ANY CHECKBOX IS UNCHECKED: DELETION IS FORBIDDEN**

### Rule Violation Response

**If this protocol is violated:**
1. **IMMEDIATE STOP**: Halt all operations
2. **ASSESS DAMAGE**: Document what was removed and what broke
3. **EMERGENCY RECOVERY**: Use rollback branch or restore from git history
4. **MANDATORY PROCESS**: Follow full protocol from Phase 1
5. **RULE UPDATE**: Add specific prevention for the violation pattern

## Integration with Existing Rules

This protocol supplements:
- `test-driven-bugfix` - Use TDD approach for migration verification
- `robust-error-handling` - Handle migration errors gracefully
- `workspace-verification` - Verify workspace state before changes
- `dont-ignore-errors` - Never ignore test failures during migration

## Critical Success Factors

### What MUST Happen
- ✅ Map ALL functionality before starting
- ✅ Migrate incrementally with verification
- ✅ Create rollback points
- ✅ Verify zero usage before deletion
- ✅ Test everything after each step

### What MUST NOT Happen
- ❌ Remove entire subsystems at once
- ❌ Skip verification "to save time"
- ❌ Assume something is unused without checking
- ❌ Delete files with ANY remaining references
- ❌ Proceed with failing tests

## Task 209 Example: What Went Wrong

**VIOLATION**: Removed `backend-detector.ts` without verifying its usage
**CONSEQUENCE**: Broke auto-detection functionality in `createConfiguredTaskService()`
**ROOT CAUSE**: Did not follow Phase 1 (functionality mapping) or Phase 3 (zero usage verification)
**RECOVERY**: Had to recreate functionality and restore missing capabilities

**This exact pattern is now FORBIDDEN by this protocol.**

## Mandatory Application Triggers

This rule MUST be applied when:
- Task description mentions removing/deleting code
- Migration from one system to another
- "Simplification" that involves elimination
- Dependency updates that remove APIs
- Refactoring that reduces code volume
- Any operation that could break existing functionality

**VIOLATION OF THIS PROTOCOL CONSTITUTES A CRITICAL PROCESS FAILURE**
