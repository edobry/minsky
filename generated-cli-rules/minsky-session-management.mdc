---
name: Minsky Session Management
description: 'Complete guide for creating, managing, and working with Minsky sessions'
tags:
  - session
  - management
  - git
  - workspace
---
# Minsky Session Management

This rule provides comprehensive guidance for creating, managing, and working with Minsky sessions.

## Overview

Sessions provide isolated development environments for working on specific tasks. Each session:

- Contains a separate git branch and workspace
- Maintains isolation from other work
- Tracks association with specific tasks
- Enables safe experimentation and development

## Session Commands

### Core Session Operations

**List all sessions**: minsky session list [--repo <value>] [--json]
- Shows all available sessions with their status and associated tasks

**Get session details**: minsky session get [--name <value>] [--task <value>] [--repo <value>] [--json]
- Retrieves detailed information about a specific session
- Can query by session name or task ID

**Create new session**: minsky session start [--name <value>] [--task <value>] [--description <value>] [--branch <value>] [--repo <value>] [--session <value>] [--json] [--quiet] [--noStatusUpdate] [--skipInstall] [--packageManager <value>]
- Creates a new session for a task
- Automatically sets up isolated workspace and git branch

**Get session directory**: minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json]
- Returns the absolute path to the session's workspace
- Essential for navigating to the correct working directory

### Advanced Session Operations

**Update session**: minsky session update [--name <value>] [--task <value>] [--repo <value>] [--branch <value>] [--noStash] [--noPush] [--force] [--json] [--skipConflictCheck] [--autoResolveDeleteConflicts] [--dryRun] [--skipIfAlreadyMerged]
- Brings session up to date with latest changes from main branch
- Handles merge conflicts and branch synchronization

**Create pull request**: minsky session pr.create [--title <value>] [--body <value>] [--bodyPath <value>] [--name <value>] [--task <value>] [--repo <value>] [--noStatusUpdate] [--debug] [--skipUpdate] [--autoResolveDeleteConflicts] [--skipConflictCheck]
- Creates a pull request from the session branch
- Integrates with task management and status updates

**Delete session**: minsky session delete [--name <value>] [--task <value>] [--force] [--repo <value>] [--json]
- Removes session workspace and branch
- Use with caution - this is destructive

## Session Lifecycle

### 1. Session Creation

Before starting work on any task:

1. **Verify task exists**: minsky tasks get <taskId> [--repo <value>] [--workspace <value>] [--session <value>] [--backend <value>] [--json]
2. **Check for existing session**: minsky session list [--repo <value>] [--json]
3. **Create session if needed**: minsky session start [--name <value>] [--task <value>] [--description <value>] [--branch <value>] [--repo <value>] [--session <value>] [--json] [--quiet] [--noStatusUpdate] [--skipInstall] [--packageManager <value>]
4. **Navigate to session**: Use minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json] output

Example workflow:
```bash
# Check if session already exists for task
```bash
minsky session list [--repo <value>] [--json]
```

# Create session for task #123 if it doesn't exist
```bash
minsky session start [--name <value>] [--task <value>] [--description <value>] [--branch <value>] [--repo <value>] [--session <value>] [--json] [--quiet] [--noStatusUpdate] [--skipInstall] [--packageManager <value>]
```

# Get session directory and navigate
```bash
minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json]
```
```

### 2. Working in Sessions

**Critical Requirements**:
- ALL implementation work MUST happen in the session workspace
- Always verify your current directory before making changes
- Never edit files in the main workspace when implementing tasks

**Navigation Pattern**:
1. Get session directory: minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json]
2. Navigate to that directory
3. Verify you're in the correct location
4. Begin implementation work

### 3. Session Maintenance

**Keep session updated**:
- Regularly sync with main branch: minsky session update [--name <value>] [--task <value>] [--repo <value>] [--branch <value>] [--noStash] [--noPush] [--force] [--json] [--skipConflictCheck] [--autoResolveDeleteConflicts] [--dryRun] [--skipIfAlreadyMerged]
- Resolve any merge conflicts promptly
- Push changes frequently to avoid data loss

**Monitor session status**:
- Check session information: minsky session get [--name <value>] [--task <value>] [--repo <value>] [--json]
- Verify task association is correct
- Ensure git branch is properly managed

### 4. Session Completion

When task implementation is complete:

1. **Final verification in session**:
   - Ensure all changes are committed
   - Run final tests in session workspace
   - Verify requirements are fully met

2. **Create pull request**: minsky session pr.create [--title <value>] [--body <value>] [--bodyPath <value>] [--name <value>] [--task <value>] [--repo <value>] [--noStatusUpdate] [--debug] [--skipUpdate] [--autoResolveDeleteConflicts] [--skipConflictCheck]
   - Generates PR from session branch
   - Links PR to associated task
   - Updates task status appropriately

3. **Post-merge cleanup**:
   - Session can be deleted after successful merge
   - Or kept for reference if needed

## Session Best Practices

### Directory Management

**Always verify location**:
- Use `pwd` to confirm current directory
- Session workspaces are completely separate from main workspace
- Changes in main workspace don't affect session workspace

**Use absolute paths**:
- Get full session path: minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json]
- Store this path for easy navigation
- Avoid relative path assumptions

### Git Management

**Branch isolation**:
- Each session has its own git branch
- Never work directly on main branch
- Session branches are automatically managed

**Commit frequently**:
- Make small, logical commits
- Push changes regularly
- Use descriptive commit messages

### Task Association

**Maintain task linkage**:
- Sessions are tied to specific tasks
- Verify task association: minsky session get [--name <value>] [--task <value>] [--repo <value>] [--json]
- Don't work on multiple tasks in one session

**Status synchronization**:
- Session operations can update task status
- Monitor status changes: minsky tasks status.get <taskId> [--repo <value>] [--workspace <value>] [--session <value>] [--backend <value>] [--json]
- Ensure status reflects actual progress

## Common Session Scenarios

### Scenario 1: Starting Fresh Task

```bash
# 1. Verify task exists and get details
minsky tasks get <taskId> [--repo <value>] [--workspace <value>] [--session <value>] [--backend <value>] [--json]

# 2. Create session for the task
minsky session start [--name <value>] [--task <value>] [--description <value>] [--branch <value>] [--repo <value>] [--session <value>] [--json] [--quiet] [--noStatusUpdate] [--skipInstall] [--packageManager <value>]

# 3. Navigate to session workspace
cd $(minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json])

# 4. Begin implementation
```

### Scenario 2: Resuming Existing Work

```bash
# 1. Check existing sessions
minsky session list [--repo <value>] [--json]

# 2. Get session directory
minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json]

# 3. Navigate and continue work
cd $(minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json])
```

### Scenario 3: Updating Session

```bash
# 1. Ensure you're in session directory
cd $(minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json])

# 2. Update session with latest changes
minsky session update [--name <value>] [--task <value>] [--repo <value>] [--branch <value>] [--noStash] [--noPush] [--force] [--json] [--skipConflictCheck] [--autoResolveDeleteConflicts] [--dryRun] [--skipIfAlreadyMerged]

# 3. Resolve any conflicts if needed
```

### Scenario 4: Creating Pull Request

```bash
# 1. Verify all changes committed in session
cd $(minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json])

# 2. Create pull request from session
minsky session pr.create [--title <value>] [--body <value>] [--bodyPath <value>] [--name <value>] [--task <value>] [--repo <value>] [--noStatusUpdate] [--debug] [--skipUpdate] [--autoResolveDeleteConflicts] [--skipConflictCheck]
```

## Troubleshooting

### Problem: Can't find session directory
**Solution**: Use minsky session dir [--name <value>] [--task <value>] [--repo <value>] [--json] to get exact path, don't guess

### Problem: Changes not appearing
**Solution**: Verify you're in session workspace, not main workspace

### Problem: Git conflicts during update
**Solution**: Follow conflict resolution process, commit resolution

### Problem: Session seems corrupted
**Solution**: Check session status with minsky session get [--name <value>] [--task <value>] [--repo <value>] [--json], consider recreating if necessary

## Integration Points

This rule integrates with:

- **task-implementation-workflow**: For complete task implementation process
- **session-first-workflow**: For the requirement that all implementation happens in sessions
- **pr-preparation-workflow**: For creating PRs from sessions
- **task-status-protocol**: For status updates during session operations